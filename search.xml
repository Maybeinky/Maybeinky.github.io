<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表与邻接表</title>
      <link href="/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
      <url>/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h3><h4 id="单链表（邻接表）"><a href="#单链表（邻接表）" class="headerlink" title="单链表（邻接表）"></a>单链表（邻接表）</h4><p>​在算法题中主要存储图和树</p><h5 id="基本样式："><a href="#基本样式：" class="headerlink" title="基本样式："></a>基本样式：</h5><p><img src="/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" alt="1"></p><p>​每个节点会存一个值和一个next指针，通常在数组模拟时用e[N]表示某个点的值是多少，用ne[N]表示next指针是多少，如上图e[0]表示零号点所存的值为3，ne[0]则表示0号点所指向的1号点，所以ne[0]&#x3D;1,以此类推e[3]&#x3D;9,ne[3]&#x3D;-1,这种类型又叫作静态列表，空节点的下标用-1来表示。算法题通常定义四个变量，head,e[N],ne[N],idx。其中head表示头结点的下标，idx存储当前已经用到了哪个点</p><h5 id="单链表插入及删除操作"><a href="#单链表插入及删除操作" class="headerlink" title="单链表插入及删除操作"></a>单链表插入及删除操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头结点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;      <span class="comment">//表示一个空集</span></span><br><span class="line">    idx = <span class="number">0</span>;        <span class="comment">//表示当前从零号点开始分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">//将x的值存在e里面</span></span><br><span class="line">    ne[idx]=head;   <span class="comment">//将x的next指针指向head所指向的值</span></span><br><span class="line">    head = idx;     <span class="comment">//将head指向x的next指针</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标为k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">//将x的值存在e里面</span></span><br><span class="line">    ne[idx]=ne[k];   <span class="comment">//将x的next指针指向head所指向的值</span></span><br><span class="line">    ne[x] = idx;     <span class="comment">//将head指向x的next指针</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标为k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><p><img src="/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/ex1.png" alt="ex1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对链表进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//最开始的时候，链表的头节点要指向-1，</span></span><br><span class="line">    <span class="comment">//为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。</span></span><br><span class="line"><span class="comment">    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当它在初始化的时候指向-1，来表示链表离没有内容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找</span></span><br><span class="line">    <span class="comment">//第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下</span></span><br><span class="line">    <span class="comment">//标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的</span></span><br><span class="line"><span class="comment">    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。</span></span><br><span class="line"><span class="comment">    另外，我们遍历链表的时候也是这样，靠的是ne[]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到头节点上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">int_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//和链表中间插入的区别就在于它有head头节点</span></span><br><span class="line">    e[idx] = x;<span class="comment">//第一步，先将值放进去</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了</span></span><br><span class="line">    <span class="comment">//先在只是做到了第一步，将元素x的指针指向了head原本指向的</span></span><br><span class="line">    head = idx;<span class="comment">//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）</span></span><br><span class="line">    idx ++;<span class="comment">//指针向下移一位，为下一次插入元素做准备。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的点的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先将元素插进去</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//让元素x配套的指针，指向它要占位的元素的下一个位置</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让原来元素的指针指向自己</span></span><br><span class="line">    idx ++;<span class="comment">//将idx向后挪</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为了将这个过程更好的理解，现在</span></span><br><span class="line"><span class="comment">    将指针转变的这个过程用比喻描述一下，牛顿老师为了省事，想插个队，队里有两个熟人</span></span><br><span class="line"><span class="comment">    张三和李四，所以，他想插到两个人中间，但是三个人平时关系太好了，只要在一起，就</span></span><br><span class="line"><span class="comment">    要让后面的人的手插到前面的人的屁兜里。如果前面的人屁兜里没有基佬的手，将浑身不</span></span><br><span class="line"><span class="comment">    适。所以，必须保证前面的人屁兜里有一只手。（张三在前，李四在后）</span></span><br><span class="line"><span class="comment">    这个时候，牛顿大步向前，将自己的手轻轻的放入张三的屁兜里，（这是第一步）</span></span><br><span class="line"><span class="comment">    然后，将李四放在张三屁兜里的手抽出来放到自己屁兜里。（这是第二步）</span></span><br><span class="line"><span class="comment">    经过这一顿骚操作，三个人都同时感觉到了来自灵魂的战栗，打了个哆嗦。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点个删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">int_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) head = ne[head];<span class="comment">//删除头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);<span class="comment">//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);<span class="comment">//同样的，第k个数，和下标不同，所以要减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表：优化某些问题"><a href="#双链表：优化某些问题" class="headerlink" title="双链表：优化某些问题"></a>双链表：优化某些问题</h4>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL中set的用法</title>
      <link href="/2023/02/19/STL%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2023/02/19/STL%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="STL中set的用法"><a href="#STL中set的用法" class="headerlink" title="STL中set的用法"></a>STL中set的用法</h3><p>set，顾名思义，就是数学上的集合——<strong>每个元素最多只出现一次，并且set中的元素已经从小到大排好序</strong>。头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”,前者的元素不能重复，而后者可以包含若干个相等的元素。</p><h3 id="头文件及声明"><a href="#头文件及声明" class="headerlink" title="头文件及声明"></a>头文件及声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;; set&lt;rec&gt; s;   <span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="type">double</span>&gt; s;</span><br></pre></td></tr></table></figure><h3 id="常用的函数："><a href="#常用的函数：" class="headerlink" title="常用的函数："></a>常用的函数：</h3><p>begin()   　　 返回set容器的第一个元素的地址</p><p>end() 　　　　 返回set容器的最后一个元素地址</p><p>clear()  　　   删除set容器中的所有的元素</p><p>empty() 　　　 判断set容器是否为空</p><p>max_size() 　  返回set容器可能包含的元素最大个数</p><p>size() 　　　　 返回当前set容器中的元素个数</p><p>erase(it)       删除迭代器指针it处元素</p><p>样例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 size 值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 maxsize的值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 中的第一个元素是 ：&quot;</span>&lt;&lt;*s.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 中的最后一个元素是:&quot;</span>&lt;&lt;*s.<span class="built_in">end</span>()&lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;set 为空 ！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 size 值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 maxsize的值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   s.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn). 在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</p><p>​    s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O(logn)。</p><p>还有两个功能类似的函数：count()和find()</p><p>1.count() :用来查找set中某个元素出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</p><p>2.find():  用来查找set中某个元素出现的位置。如果找到，就返回这个元素的迭代器，如果这个元素不存在，则返回 s.end() 。 (最后一个元素的下一个位置，s为set的变量名)</p><h3 id="set的遍历"><a href="#set的遍历" class="headerlink" title="set的遍历"></a>set的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     set&lt;<span class="type">int</span>&gt; s;                <span class="comment">//创建一个int类型的set</span></span><br><span class="line">  </span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">10</span>);                <span class="comment">//插入数据</span></span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">40</span>);                 </span><br><span class="line">     <span class="comment">//遍历数据，用迭代器遍历数据</span></span><br><span class="line">     <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)    </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里用到了set中的元素已经从小到大排好序的性质</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后，不得不提的就是结构体类型（struct ）的set ，使用时必须要重载 ‘&lt;’ 运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Info &amp;a) <span class="type">const</span> <span class="comment">// 重载“&lt;”操作符，自定义排序规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按score由大到小排序。如果要由小到大排序，使用“&gt;”即可。</span></span><br><span class="line">        <span class="keyword">return</span> a.score &lt; score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Info&gt; s;</span><br><span class="line">    Info info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入三个元素</span></span><br><span class="line">    info.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    info.score = <span class="number">80</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line">    info.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    info.score = <span class="number">99</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line">    info.name = <span class="string">&quot;Steaven&quot;</span>;</span><br><span class="line">    info.score = <span class="number">60</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line"></span><br><span class="line">    set&lt;Info&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; (*it).name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; (*it).score &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Tom : 99</span></span><br><span class="line"><span class="comment">//Jack : 80</span></span><br><span class="line"><span class="comment">//Steaven : 60</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解ex1</title>
      <link href="/2023/02/14/%E9%A2%98%E8%A7%A3ex1/"/>
      <url>/2023/02/14/%E9%A2%98%E8%A7%A3ex1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2023/02/14/%E9%A2%98%E8%A7%A3ex1/ex1.png" alt="ex1"></p><p><strong>这道题可以双指针、哈希，但也可以二分，这里就把三种一起讲掉啦！</strong></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h4><p><strong>我们先简化一下问题，变成求Ai+Bj&gt;=x且j要最小。</strong></p><p><strong>我们可以用一个指针i来枚举A中所有数，而用j来枚举B，但由于数组是单调递增的，所以如果Ai+Bj&gt;=x那么Bj+1到Bm就不可能是答案。</strong></p><p><strong>所以j是只能递减的，如此，我们便可以用O(n+m)的时间复杂度通过这道题。</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)cin&gt;&gt;b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]+b[j]&gt;=x)j--;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[i]+b[j+<span class="number">1</span>]==x)</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="二分思路"><a href="#二分思路" class="headerlink" title="二分思路"></a>二分思路</h4><p><strong>既然要找两个和为x的数，那么我们可以把他转换成确定一个y为A，然后快速在B中找出x-y的问题。</strong></p><p><strong>显然我们可以二分查找，算法复杂度为O(nlogn)，可以AC。</strong></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> y = x - a[i];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[mid] == y) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b[mid] &lt; y) </span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="哈希思路"><a href="#哈希思路" class="headerlink" title="哈希思路"></a>哈希思路</h4><p><strong>这个没啥说的，我们可以在输入A时把每个数存在哈希表里，对于每个输入的Bi看看x-Bi是否出现与哈希表即可。</strong></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        h[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">count</span>(x - b[i])) </span><br><span class="line">            cout &lt;&lt; h[x - b[i]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p align="right">written by May(ゝ∀･)</p>                                                                                                                                                        ]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法</title>
      <link href="/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><p>​        </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//用i“扫描”一遍</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;<span class="built_in">check</span>(i,j))j++;<span class="comment">//确定j的范围以及满足的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,j&lt;n;j++)<span class="comment">//j:j往左最远能到什么地方，j具有单调性</span></span><br><span class="line"><span class="built_in">O</span>(n^<span class="number">2</span>)<span class="comment">//优化时间复杂度，双指针算法为O(n)</span></span><br></pre></td></tr></table></figure><h4 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素算法：O(n^2)//双指针算法：O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">chack</span>(j,i))<span class="keyword">while</span>(j&lt;=i&amp;&amp;<span class="built_in">check</span>(j,i))j++;</span><br><span class="line">            &#123;res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p> <img src="/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/ex1.jpg" alt="ex1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];<span class="comment">//s[N]记录某个数出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;<span class="comment">//向s[]中添加新元素</span></span><br><span class="line">        <span class="keyword">while</span>(s[a[i]]&gt;<span class="number">1</span>)<span class="comment">//如果s[]中存在重复元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--;<span class="comment">//将该元素删去</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过hexo与github搭建个人平台</title>
      <link href="/2023/01/29/%E9%80%9A%E8%BF%87hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/01/29/%E9%80%9A%E8%BF%87hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><ul><li>搭建个人博客组成<ul><li>博客生成框架</li><li>文件托管平台</li><li>站点部署服务</li><li>访问加速服务</li></ul></li></ul><h5 id="博客生成框架"><a href="#博客生成框架" class="headerlink" title="博客生成框架"></a>博客生成框架</h5><p>​它的作用是将用户的输入转化成一个网站目录，由一些html文件，css文件以及js文件组成的目录结构。</p><p>​HTML（Hyper Text Markup Language）又名超文本标记语言，是前端的结构层，从语意的角度去搭建网页结构</p><p>​CSS（Cascading Style Sheet）译为层叠样式表，是前端的样式层，从美观的角度去修饰页面样式</p><p>​js（JavaScript）一种脚本语言，前端的行为层，从交互的角度去描述页面行为</p><p>​简单来说一个博客框架所要达到的效果是作为用户的我们能够以一种相对简单的方式进行博客的设置和书写，然后框架负责帮助我们把这些简单的东西转化成一个完整的复杂的前端界面，本文内容主要以hexo为框架，通过hexo，我们可以用yml进行博客的设置，用markdown来进行博客的书写，hexo会帮我们把这些内容转化成一个完整的网站目录，存放在public文件夹中</p><h5 id="文件托管平台"><a href="#文件托管平台" class="headerlink" title="文件托管平台"></a>文件托管平台</h5><p>​它的作用能够让我们把文件储存在云端并提供相应的访问和修改的接口（当然你是富哥也可以自己买个服务器bushi），本文使用的文件托管平台是github，访问和修改的接口是git</p><h5 id="站点部署服务"><a href="#站点部署服务" class="headerlink" title="站点部署服务"></a>站点部署服务</h5><p>​顾名思义，将一个已经成形的网站部署到互联网上，让网络上的其他主机能够正常访问，我们可以使用github自带的github pages，但是这个站点国内访问速度极慢，本文将使用netlify作为我们部署站点的服务提供商，而把github仅仅作为一个托管文件的场所，这样，我们就能享受到netlify本身的国外加速服务。</p><p>​此外，netlify除了直接部署静态网站的功能之外，还支持动态的构建网站，也就是我们可以自定义一个构建网站的脚本，如npm run clean &amp;&amp; npm run build等脚本，这会先清除之前已经构建好的静态网站，然后重新从头构建，以防某些地方的更新不到位。这样之后我们每次向github commit的时候，netlify都会自动pull并执行上述的脚本，从而保证网站的实时更新</p><h5 id="访问加速服务"><a href="#访问加速服务" class="headerlink" title="访问加速服务"></a>访问加速服务</h5><p>​原理是CDN(Content Deliver Network)加速，即内容交付网络，其原理是通过多结点的缓存来提高网络内容的解析和访问速度，利用的是页面访问的局限性，也就是说刚刚访问过的页面很可能再过不久就会再次访问，这其实和计算机系统中的多级缓存利用程序的局部性是一致的，一个程序刚刚访问过的内存地址附近的地址很可能不久就会再次被访问</p><p>​其基本工作过程是让客户端先访问离自己最近的DNS（Domain Name System）服务器结点，以获取目标内容所在的结点信息，然后根据这个信息去询问CDN服务器结点，由CDN负责从网络中寻找远端的实际存储内容的服务器进行内容的获取，然后将获取的内容缓存下来，这样的话下一次访问就会比较迅速了，从而实现了对网络内容交付的加速</p><p>​这里需要DNS服务器和CDN服务器相互配合，因此他们一般是同一个服务提供商的，比如本文使用的clouldflare。一般来说，我们购买域名之后，提供商默认会为我们分配他自己的DNS服务器，我们需要将这个服务器改成clou了、dflare的DNS服务器，才能享受clouldflare的CDN加速服务</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n log²n)</td><td>O(n log²n)</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(n²)</td><td>O(log n)</td><td>in-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>out-place</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>out-place</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>out-place</td><td>稳定</td></tr></tbody></table></div><h3 id="排序算法简介说明"><a href="#排序算法简介说明" class="headerlink" title="排序算法简介说明"></a>排序算法简介说明</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将一组杂乱无章的数据按一定的规律顺次排列起来。例如：</p><p>输入：a1，a2，a3，…，an</p><p>输出：a1’，a2’，a3’，…，an’（满足a1′ &lt;= a2′ &lt;= a3′ &lt;= … &lt;= an’排列）</p><h4 id="2-算法性能评估术语言"><a href="#2-算法性能评估术语言" class="headerlink" title="2. 算法性能评估术语言"></a>2. 算法性能评估术语言</h4><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b时，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b时，排序之后a可能出现在b的后面。</p><p><strong>内排序</strong>：所有排序操作都在内存中完成。<br><strong>外排序</strong>：通常是由于数据太大，不能同时存放在内存中，根据排序过程的需要而在外存与内存之间 数据传输才能进行。</p><p><strong>时间复杂度</strong>：时间频度，一个算法执行所耗费的时间。算法中通常用数据比较次数与数据移动次数 进行衡量。<br><strong>空间复杂度</strong>：算法执行所需要的内存大小。</p></blockquote><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>​        插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 从第一个元素开始，该元素可以认为已经被排序<br>② 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④ 重复步骤③，直到找到已排序的元素小于或者等于新元素的位置<br>⑤将新元素插入到该位置后<br>⑥ 重复步骤②~⑤</p></blockquote><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort.gif" alt="InsertionSort"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><blockquote><p>平均时间复杂度：O(N^2)<br>最差时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>排序方式：In-place<br>稳定性：稳定</p></blockquote><p>如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：</p><blockquote><p>(1) 最好情况：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。<br>(2) 最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。</p></blockquote><p>插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(N^2)。</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0；</p><p>最差的空间复杂度为开始元素为逆排序，则空间复杂度最坏时为 O(N);</p><p>平均的空间复杂度为O(1)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查数据合法性</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//如果比tmp大把值往后移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class="line">               arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法优化改进"><a href="#算法优化改进" class="headerlink" title="算法优化改进"></a>算法优化改进</h4><h5 id="改进方法①"><a href="#改进方法①" class="headerlink" title="改进方法①"></a>改进方法①</h5><p>场景分析：</p><p>直接插入排序每次往前插入时，是按顺序依次往前查找，数据量较大时，必然比较耗时，效率低。</p><p>改进思路： 在往前找合适的插入位置时采用二分查找的方式，即折半插入。</p><p>二分插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，相比直接插入排序，在速度上有一定提升。逻辑步骤：</p><blockquote><p>① 从第一个元素开始，该元素可以认为已经被排序<br>② 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置<br>③将新元素插入到该位置后<br>④ 重复上述两步</p></blockquote><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序改进：二分插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> key, left, right, middle;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        key = a[i];   </span><br><span class="line">        left = <span class="number">0</span>;   </span><br><span class="line">        right = i<span class="number">-1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)   </span><br><span class="line">        &#123;   </span><br><span class="line">            middle = (left+right)/<span class="number">2</span>;   </span><br><span class="line">            <span class="keyword">if</span> (a[middle]&gt;key)   </span><br><span class="line">                right = middle<span class="number">-1</span>;   </span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                left = middle+<span class="number">1</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=left; j--)   </span><br><span class="line">        &#123;   </span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        a[left] = key;          </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进方法②"><a href="#改进方法②" class="headerlink" title="改进方法②"></a>改进方法②</h5><p>场景分析：</p><p>(1) 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。</p><p>(2) 插入排序在每次往前插入时只能将数据移动一位，效率比较低。</p><p>改进思路：</p><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p><p>改进思路二的方法实际上就是希尔排序。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。尤其当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率。 在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。</p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>​        冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。</p><p>​        重复走访要排序的数列，通过两两比较相邻记录的排序码。排序过程中每次从后往前冒一个最小值，且每次能确定一个数在序列中的最终位置。若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。</p><h4 id="实现逻辑-1"><a href="#实现逻辑-1" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p>通过两层循环控制：</p><ul><li>第一个循环（外循环），负责把需要冒泡的那个数字排除在外；</li><li>第二个循环（内循环），负责两两比较交换。</li></ul><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/BubbleSort.gif" alt="BubbleSort"></p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>平均时间复杂度：O(N^2)</li><li>最佳时间复杂度：O(N)</li><li>最差时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>排序方式：In-place</li><li>稳定性：稳定</li></ul><p>解析说明：</p><p>冒泡排序涉及相邻两两数据的比较，故需要嵌套两层 for 循环来控制;</p><p>外层循环 n 次，内层最多时循环 n – 1次、最少循环 0 次，平均循环(n-1)/2;</p><p>所以循环体内总的比较交换次数为：n*(n-1) / 2 = (n^2-n)/2 ;</p><p>按照计算时间复杂度的规则，去掉常数、去掉最高项系数，其复杂度为O(N^2) ;</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0;</p><p>最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);</p><p>平均的空间复杂度为O(1) .</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序(C++)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> i, j;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; len - i; j++)  </span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])  </span><br><span class="line">                <span class="built_in">swap</span>(arr[j - <span class="number">1</span>], arr[j]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h4><h5 id="改进方法①-1"><a href="#改进方法①-1" class="headerlink" title="改进方法①"></a>改进方法①</h5><p>场景一：</p><p>在某次遍历中如果没有数据交换，说明整个数组已经有序。若初始序列就是排序好的，如果用基础的冒泡排序方法，仍然还要比较O(N^2)次，但无交换次数。</p><p>改进思路：</p><p>通过设置标志位来记录此次遍历有无数据交换，进而可以判断是否要继续循环，设置一个flag标记，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变。</p><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序改进(C++)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;        <span class="comment">//比较n-1次</span></span><br><span class="line">        <span class="type">bool</span> exchange = <span class="literal">true</span>;               <span class="comment">//冒泡的改进，若在一趟中没有发生逆序，则该序列已有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len<span class="number">-1</span>; j &gt;i; j--)&#123;     <span class="comment">//每次从后边冒出一个最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])&#123;       <span class="comment">//发生逆序，则交换</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">                exchange = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进方法②-1"><a href="#改进方法②-1" class="headerlink" title="改进方法②"></a>改进方法②</h5><p>场景二：</p><p>如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了。</p><p>改进思路：</p><p>记录某次遍历时最后发生数据交换的位置pos，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序改进②</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> j, k;  </span><br><span class="line">    <span class="type">int</span> flag;  </span><br><span class="line">    flag = len;  </span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k = flag;  </span><br><span class="line">        flag = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; k; j++)  </span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">swap</span>(arr[j - <span class="number">1</span>], arr[j]);  </span><br><span class="line">                flag = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，建议采用其它排序方法。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>希尔排序的实质就是分组插入排序，该方法又称递减增量排序算法，因DL．Shell于1959年提出而得名。希尔排序是非稳定的排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><blockquote><p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p></blockquote><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p><p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><h4 id="实现逻辑-2"><a href="#实现逻辑-2" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。<br>② 所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。<br>③ 取第二个增量d2小于d1重复上述的分组和排序，直至所取的增量dt=1(dt小于dt-l小于…小于d2小于d1)，即所有记录放在同一组中进行直接插入排序为止。</p></blockquote><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ShellSort.gif" alt="ShellSort"></p><p>具体我们以一组数字来说操作说明：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ShellSort.jpg" alt="ShellSort"></p><p>假设有一组｛9, 1, 2, 5, 7, 4, 8, 6, 3, 5｝无需序列。</p><blockquote><p><strong>第一趟排序</strong>： 设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。<br><strong>第二趟排序</strong>：<br>将上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为2组。按照直接插入排序的方法对每个组进行排序。<br><strong>第三趟排序</strong>：<br>再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为1的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p></blockquote><p><em>注：需要注意一下的是，图中有两个相等数值的元素5和5。我们可以清楚的看到，在排序过程中，两个元素位置交换了。</em></p><h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h4><blockquote><p>平均时间复杂度：O(Nlog2N)<br>最佳时间复杂度：<br>最差时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：不稳定<br>复杂性：较复杂</p></blockquote><p>希尔排序的效率取决于增量值gap的选取，时间复杂度并不是一个定值。</p><p>开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0；最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);平均的空间复杂度为O(1)希尔排序并不只是相邻元素的比较，有许多跳跃式的比较，难免会出现相同元素之间的相对位置发生变化。比如上面的例子中希尔排序中相等数据5就交换了位置，所以希尔排序是不稳定的算法。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++实现</span></span><br><span class="line"><span class="comment">// 可以使用整数或浮点数作为元素，如果使用类(class)作为元素则需要重载大于(&gt;)运算符。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> gap, i, j;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重点说明-步-摘录自wiki百科"><a href="#重点说明-步-摘录自wiki百科" class="headerlink" title="重点说明(步( 摘录自wiki百科)"></a>重点说明(步( 摘录自wiki百科)</h4><h5 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a><strong>步长序列</strong></h5><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>作者最初的建议是折半再折半知道最后的步长为1&lt;也就是插入排序&gt;,虽然这样取可以比O(n2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如, 如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p><h5 id="常见步长序列"><a href="#常见步长序列" class="headerlink" title="常见步长序列"></a><strong>常见步长序列</strong></h5><blockquote><p>①步长序列：n/2i 最坏情况复杂度：O(n2)<br>②步长序列：2k-1 最坏情况复杂度：O(n3/2)<br>③步长序列：2i3j 最坏情况复杂度：O(nlog2n)</p></blockquote><p><strong>*注意</strong>：由于显示特殊符号存在问题，步长序列中i、k-1，j等都是右上标符号。*</p><p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自9 x 4i – 9 x 2i + 1 和 2i+2 x (2i+2 -3)这两个算式。(注意：公众号里面无法显示特殊符号，两个公式中i，j等都是右上标符号)</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。</p><p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序，又称划分交换排序（partition-exchange sort）</p><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="实现逻辑-3"><a href="#实现逻辑-3" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><blockquote><p>① 从数列中挑出一个元素，称为 “基准”（pivot），<br>② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/QuickSort.gif" alt="QuickSort"></p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><blockquote><p>平均时间复杂度：O(NlogN)<br>最佳时间复杂度：O(NlogN)<br>最差时间复杂度：O(N^2)<br>空间复杂度：根据实现方式的不同而不同</p></blockquote><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,x=q[(l+r)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j),<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，很多面试题中也经常遇到。对于其算法的改进，除了刚刚上文中提到的意外，根据实际场景还有诸多改进方法，包括对小序列采用插入排序替代，三平均划分，三分区划分等改进方法。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><h4 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h4><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><h4 id="实现逻辑-4"><a href="#实现逻辑-4" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><blockquote><p>① 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>② 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③ 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④ 重复步骤③直到某一指针到达序列尾<br>⑤ 将另一序列剩下的所有元素直接复制到合并序列尾</p></blockquote><h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a><strong>递归法</strong></h5><blockquote><p>① 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素<br>② 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素<br>③ 重复步骤②，直到所有元素排序完毕</p></blockquote><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/MergeSort.gif" alt="MergeSort"></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(nlogn)<br>最佳时间复杂度：O(n)<br>最差时间复杂度：O(nlogn)<br>空间复杂度：O(n)<br>排序方式：In-place<br>稳定性：稳定</p></blockquote><p>不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )</p><p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)。</p><p>归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进-1"><a href="#优化改进-1" class="headerlink" title="优化改进"></a>优化改进</h4><p>在规模较小时，合并排序可采用直接插入，避免递归调用； 在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完。 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>归并排序和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="前缀知识"><a href="#前缀知识" class="headerlink" title="前缀知识"></a>前缀知识</h4><p>堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树</p><h5 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h5><blockquote><p>① 是一棵完全二叉树<br>② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</p></blockquote><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.jpg" alt="Heep1"></p><h5 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h5><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)</p><h5 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h5><p>在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><blockquote><p>① <strong>最大堆调整（Max_Heapify）</strong>：将堆的末端子节点作调整，使得子节点永远小于父节点<br>② <strong>创建最大堆（Build_Max_Heap）</strong>：将堆所有数据重新排序<br>③ <strong>堆排序（HeapSort）</strong>：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p></blockquote><h4 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h4><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p><blockquote><p>① 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点<br>② 依次将根节点与待排序序列的最后一个元素交换<br>③ 再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列</p></blockquote><h4 id="实现逻辑-5"><a href="#实现逻辑-5" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。<br>② 再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key<br>③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>④ 直到无序区只有一个元素为止。</p></blockquote><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heepsort1.gif" alt="Heepsort1"></p><p>​    堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><p><strong>分步解析说明</strong>：</p><p>实现堆排序需要解决两个问题：</p><blockquote><p>1、如何由一个无序序列建成一个堆？<br>2、如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p></blockquote><p>假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep2.jpg" alt="Heep2"></p><h5 id="创建最大堆"><a href="#创建最大堆" class="headerlink" title="创建最大堆"></a>创建最大堆</h5><p>①首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆。每一个三角关系都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子；</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.1.jpg" alt="Heep1.1"></p><p>②转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.1.jpg" alt="Heep1.1"></p><p>③从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。</p><p>④第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.2.jpg" alt="Heep1.2"></p><p>⑤对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。</p><p>⑥最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.3.jpg" alt="Heep1.3"></p><h5 id="堆排序（最大堆调整）"><a href="#堆排序（最大堆调整）" class="headerlink" title="堆排序（最大堆调整）"></a>堆排序（最大堆调整）</h5><p>①首先将堆顶元素100交换至最底部7的位置，7升至堆顶，100所在的底部位置即为有序区，有序区不参与之后的任何对比。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.4.jpg" alt="Heep1.4"></p><p>②在7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.5.jpg" alt="Heep1.5"></p><p>③在7被交换下来后，下面还有子节点，所以需要继续与子节点对比，左孩子11比7大，所以11与7交换位置，交换位置后7下面为有序区，不参与对比，所以本轮结束，无序区再次形成一个最大堆。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.6.jpg" alt="Heep1.6"></p><p>④将最大堆堆顶33交换至堆末尾，扩大有序区；</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.7.jpg" alt="Heep1.7"></p><p>⑤不断建立最大堆，并且扩大有序区，最终全部有序。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.8.jpg" alt="Heep1.8"></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>平均时间复杂度：O(nlogn)</li><li>最佳时间复杂度：O(nlogn)</li><li>最差时间复杂度：O(nlogn)</li><li>稳定性：不稳定</li></ul><p>堆排序其实也是一种选择排序，是一种树形选择排序。只不过直接选择排序中，为了从R[1…n]中选择最大记录，需比较n-1次，然后从R[1…n-2]中选择最大记录需比较n-2次。事实上这n-2次比较中有很多已经在前面的n-1次比较中已经做过，而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。对于n个关键字序列，最坏情况下每个节点需比较log2(n)次，因此其最坏情况下时间复杂度为nlogn。堆排序为不稳定排序，不适合记录较少的排序。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>堆是一种很好做调整的结构，在算法题里面使用频度很高。常用于想知道最大值或最小值的情况，比如优先级队列，作业调度等场景。</p><p>堆排序相看似比较复杂（建堆的过程，堆调整的过程，堆排序等等），需要好好推敲揣摩理清思路。堆排序操作过程中其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</p><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p><strong>计数排序（Counting sort）</strong>是一种稳定的线性时间排序算法。</p><h4 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h4><p>计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），然后进行分配、收集处理：</p><blockquote><p>① <strong>分配</strong>。扫描一遍原始数组，以当前值-minValue作为下标，将该下标的计数器增1。<br>② <strong>收集</strong>。扫描一遍计数器数组，按顺序把值收集起来。</p></blockquote><h4 id="实现逻辑-6"><a href="#实现逻辑-6" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 找出待排序的数组中最大和最小的元素<br>② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>④ 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></blockquote><h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CountingSort.gif" alt="CountingSort"></p><p>举个例子，假设有无序数列nums=[2, 1, 3, 1, 5], 首先扫描一遍获取最小值和最大值，maxValue=5, minValue=1，于是开一个长度为5的计数器数组counter</p><blockquote><p><strong>(1) 分配</strong><br>统计每个元素出现的频率，得到counter=[2, 1, 1, 0, 1]，例如counter[0]表示值0+minValue=1出现了2次。<br><strong>(2) 收集</strong><br>counter[0]=2表示1出现了两次，那就向原始数组写入两个1，counter[1]=1表示2出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为[1,1,2,3,5]，排序好了。</p></blockquote><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n + k)<br>空间复杂度：O(n + k)</p></blockquote><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。</p><p>计数排序需要两个额外的数组用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)。</p><p>计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。</p><p>计数排序的稳定性很重要的一个原因是：计数排序经常会被用于基数排序算法的一个子过程。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> maxVal)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxVal+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line">count[x]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxVal; ++i)</span><br><span class="line">count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">arr[count[tmp[i]] - <span class="number">1</span>] = tmp[i];</span><br><span class="line">count[tmp[i]]--;<span class="comment">//注意这里要减1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> maxVal = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">CountSort</span>(arr,maxVal);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进-2"><a href="#优化改进-2" class="headerlink" title="优化改进"></a>优化改进</h4><p><strong>场景分析：</strong>举个极端的例子：如果排序的数组有200W个元素，但是这200W个数的值都在1000000-1000100，也就说有100个数，总共重复了200W次，现在要排序，怎么办？</p><p>这种情况排序，计数排序应该是首选。但是这时候n的值为200W，如果按原来的算法，k的值10001000，但是此时c中真正用到的地方只有100个，这样对空间造成了极大的浪费。</p><p><strong>改进思路：</strong>针对c数组的大小，优化计数排序</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>计数算法只能使用在已知序列中的元素在0-k之间，且要求排序的复杂度在线性效率上。 Â 计数排序和基数排序很类似，都是非比较型排序算法。但是，它们的核心思想是不同的，基数排序主要是按照进制位对整数进行依次排序，而计数排序主要侧重于对有限范围内对象的统计。基数排序可以采用计数排序来实现。</p><h3 id="桶排序（BucketSort）"><a href="#桶排序（BucketSort）" class="headerlink" title="桶排序（BucketSort）"></a>桶排序（BucketSort）</h3><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p><h4 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h4><p>桶排序的思想近乎彻底的<strong>分治思想</strong>。</p><p>桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。</p><p>然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。</p><p>接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。</p><blockquote><p>补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数</p></blockquote><p>为了使桶排序更加高效，我们需要做到这两点：</p><blockquote><p>1、在额外空间充足的情况下，尽量增大桶的数量；<br>2、使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中；</p></blockquote><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h4 id="实现逻辑-7"><a href="#实现逻辑-7" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><ul><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ul><h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/BucketSort.gif" alt="BucketSort"></p><p>分步骤图示说明：设有数组 array = [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]，对其进行桶排序：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket.jpg" alt="Bucket"></p><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n ^ 2)<br>空间复杂度：O(n * k)<br>稳定性：稳定</p></blockquote><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p>假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">ListNode* mNext;</span><br><span class="line"><span class="type">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">ListNode *pre,*curr;</span><br><span class="line">dummyNode.mNext = head;</span><br><span class="line">pre = &amp;dummyNode;</span><br><span class="line">curr = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;mNext = curr;</span><br><span class="line">pre-&gt;mNext = newNode;</span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *dummy = &amp;dummyNode;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line"><span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">dummy-&gt;mNext = head1;</span><br><span class="line">head1 = head1-&gt;mNext;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dummy-&gt;mNext = head2;</span><br><span class="line">head2 = head2-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="type">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">arr[i] = head-&gt;mData;</span><br><span class="line">head = head-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>桶排序是计数排序的变种，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p><p>算法思想和散列中的开散列法差不多，当冲突时放入同一个桶中；可应用于数据量分布比较均匀，或比较侧重于区间数量时。</p><p>桶排序最关键的建桶，如果桶设计得不好的话桶排序是几乎没有作用的。通常情况下，上下界有两种取法，第一种是取一个10^n或者是2^n的数，方便实现。另一种是取数列的最大值和最小值然后均分作桶.</p><h3 id="基数排序（RadixSort）"><a href="#基数排序（RadixSort）" class="headerlink" title="基数排序（RadixSort）"></a>基数排序（RadixSort）</h3><p>基数排序（Radix sort）是一种非比较型整数排序算法。</p><h4 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h4><p>原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><ul><li><strong>MSD</strong>：先从高位开始进行排序，在每个关键字上，可采用计数排序</li><li><strong>LSD</strong>：先从低位开始进行排序，在每个关键字上，可采用桶排序</li></ul><h4 id="实现逻辑-8"><a href="#实现逻辑-8" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>② 从最低位开始，依次进行一次排序。<br>③ 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><h4 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h4><p>google上没搜到吗，因此没有动图演示。</p><p>分步图示说明：设有数组 array = {53, 3, 542, 748, 14, 214, 154, 63, 616}，对其进行基数排序：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/RadixSort.jpg" alt="RadixSort"></p><p>在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。</p><ul><li>按照个位数进行排序。</li><li>按照十位数进行排序。</li><li>按照百位数进行排序。</li></ul><p>排序后，数列就变成了一个有序序列。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>时间复杂度：O(k*N)<br>空间复杂度：O(k + N)<br>稳定性：稳定</p></blockquote><p>设待排序的数组R[1..n]，数组中最大的数是d位数，基数为r（如基数为10，即10进制，最大有10种可能，即最多需要10个桶来映射数组元素）。</p><p>处理一位数，需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历数组一遍，最多元素数为n，则时间复杂度为O(n+r)。所以，总的时间复杂度为O(d*(n+r))。</p><p>基数排序过程中，用到一个计数器数组，长度为r，还用到一个r<em>n的二位数组来做为桶，所以空间复杂度为O(r</em>n)。</p><p>基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];      <span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*    int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><p>基数排序不是直接根据元素整体的大小进行元素比较，而是将原始列表元素分成多个部分，对每一部分按一定的规则进行排序，进而形成最终的有序列表。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp语法</title>
      <link href="/2023/01/28/cpp%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/28/cpp%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1><h4 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h4><h6 id="D-i，-j-xi-xj-yi-yj"><a href="#D-i，-j-xi-xj-yi-yj" class="headerlink" title="D (i， j)=|xi-xj|+|yi-yj|"></a>D (i， j)=|xi-xj|+|yi-yj|</h6><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><h6 id="证明：设a-k-b-r-k和r分别是a除以b得到的商和余数"><a href="#证明：设a-k-b-r-k和r分别是a除以b得到的商和余数" class="headerlink" title="证明：设a=k*b+r,k和r分别是a除以b得到的商和余数"></a>证明：设a=k*b+r,k和r分别是a除以b得到的商和余数</h6><p>则有a-r=k<em>b成立<br>设d是a和b的公约数<br>那么由a=k</em>b+r，得d也是r的一个因数<br>因此d是b和r的公因数<br>因此d既是a和b的公因数，也是b和a%b的公因数<br>那么，最大公因数也相等<br>即gcd=(a,b)=gcd(b,a%b)<br>证毕。</p><p>int gcd(int a,int b)</p><p>{<br>    if(b==0)<br>        return a;<br>    else<br>        return gcd(b,a%b);<br>}</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;          <span class="comment">//动态变化的int数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;rec&gt; c;          <span class="comment">//自定义结构体类型也可保存于vector</span></span><br><span class="line"></span><br><span class="line">size<span class="comment">//函数返回vector的实际长度</span></span><br><span class="line"></span><br><span class="line">empty<span class="comment">//函数返回一个bool类型</span></span><br><span class="line"></span><br><span class="line">clear<span class="comment">//函数把vector清空</span></span><br></pre></td></tr></table></figure><h4 id="迭代器（类似STL的指针）"><a href="#迭代器（类似STL的指针）" class="headerlink" title="迭代器（类似STL的指针）"></a>迭代器（类似STL的指针）</h4><p>声明：vector<int>::iterator it;</int></p><p>begin函数返回vector第一个元素的迭代器，*a.begin()与a[0]相同,end同理</p><p>front函数返回vector第一个元素</p><p>back函数返回vector最后一个元素</p><p>a.push_back(x)把元素x插入vector a的尾部</p><p>b.pop_back()删除vector a的最后一个元素</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>include <queue>包括循环队列queue和优先队列priority_queue两个容器</queue></p><p>声明: queue<int> q;</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;...&#125;;queue&lt;rec&gt;q     <span class="comment">//rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">priority queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;q;  <span class="comment">//小于堆</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列 queue</span></span><br><span class="line"></span><br><span class="line">   push 从队尾插入</span><br><span class="line"></span><br><span class="line">   pop 从队头弹出</span><br><span class="line"></span><br><span class="line">   front 返回队头元素</span><br><span class="line"></span><br><span class="line">   back 返回队尾元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先队列 priority_queue</span></span><br><span class="line"></span><br><span class="line">   push 把元素插入堆</span><br><span class="line"></span><br><span class="line">   pop 删除堆顶元素</span><br><span class="line"></span><br><span class="line">   top 查询堆顶元素（最大值）</span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p> include <stack></stack></p><p>头文件stack包含栈。声明和前面的容器类似。</p><p>push 向栈顶插入</p><p>pop 弹出栈顶元素</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间,类似vector和queue的结合</p><p>begin/end，返回deque的头/尾迭代器</p><p>front/back 队头/队尾元素</p><p>push_back 从队尾入队</p><p>push_front 从队头入队</p><p>pop_back 从队尾出队</p><p>pop_front 从队头出队</p><p>clear 清空队列</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line">  map&lt;key_type, value_type&gt; name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//例如：</span></span><br><span class="line"></span><br><span class="line">  map&lt;<span class="type">long</span>, <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">  map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>&amp; 与</p><p>| 或</p><p>~ 非</p><p>^ 异或</p><p>>&gt; 右移</p><p>&lt;&lt; 左移</p><p>常用操作：</p><p>(1)  求x的第k位数字 x &gt;&gt; k &amp; 1                          //1.先把第k位移到最后一位x&gt;&gt;k；2.再看看个位是几 x&1;</p><p>(2)  lowbit(x) ，返回x的最后一位1      //若x=101000，则lowbit(x)=1000; x=1010，则lowbit(x)=10;</p><p>​      x&amp;-x==x&amp;(~x+1)</p><p>​      若x=101000，则~x=010111，~x+1=010100，x&amp;(~x+1)=0001000</p><h4 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h4><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>​    翻转一个vector</p><p>​    reverse(a.begin(),a,end());</p><p>​    翻转一个数组</p><p>​    reverse（a+1，a+1+n）;</p><h5 id="unique-前闭后开"><a href="#unique-前闭后开" class="headerlink" title="unique(前闭后开)"></a>unique(前闭后开)</h5><p>​    去重vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m =<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())-a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>​    去重数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m =<span class="built_in">unique</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-(a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="random-shuffle（随机打乱）"><a href="#random-shuffle（随机打乱）" class="headerlink" title="random,shuffle（随机打乱）"></a>random,shuffle（随机打乱）</h5><p>​    用法和reverse相同</p><h5 id="sort-快排"><a href="#sort-快排" class="headerlink" title="sort(快排)"></a>sort(快排)</h5><p>​    sort(a.begin(),a.end())</p><h5 id="lower-bound-upper-bound-二分"><a href="#lower-bound-upper-bound-二分" class="headerlink" title="lower_bound/upper_bound(二分)"></a>lower_bound/upper_bound(二分)</h5><p>​    解析:lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。</p><p>upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p><p>​    在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> I = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n,. x) – a;</span><br></pre></td></tr></table></figure><p>在有序vector<int> 中查找小于等于x的最大整数（假设一定存在）</int></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = *--<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
