<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mimosa</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-22T08:44:30.907Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>科学上网的一些原理</title>
    <link href="http://example.com/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-22T08:24:47.000Z</published>
    <updated>2023-02-22T08:44:30.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="知其所以然"><a href="#知其所以然" class="headerlink" title="知其所以然"></a>知其所以然</h2><p>本文不是教程向，倾向于分析科学上网的一些原理。知其所以然，才能更好地使用工具，也可以创作出自己的工具。</p><p>科学上网的工具很多，八仙过海，各显神通，而且综合了各种技术。尝试从以下四个方面来解析一些其中的原理。大致先原理，再工具的顺序。</p><ul><li>dns</li><li>http&#x2F;https proxy</li><li>vpn</li><li>socks proxy</li></ul><h2 id="一个http请求发生了什么？"><a href="#一个http请求发生了什么？" class="headerlink" title="一个http请求发生了什么？"></a>一个http请求发生了什么？</h2><p>这个是个比较流行的面试题，从中可以引出很多的内容。大致分为下面四个步骤：</p><ul><li>dns解析，得到IP</li><li>向目标IP发起TCP请求</li><li>发送http request</li><li>服务器回应，浏览器解析</li></ul><p>还有很多细节，更多参考：</p><p><a href="http://fex.baidu.com/blog/2014/05/what-happen/">输入url到页面加载会发生什么事</a></p><h2 id="DNS-x2F-域名解析"><a href="#DNS-x2F-域名解析" class="headerlink" title="DNS&#x2F;域名解析"></a>DNS&#x2F;域名解析</h2><p>可以看到dns解析是最初的一步，也是最重要的一步。比如访问亲友，要知道他的正确的住址，才能正确地上门拜访。</p><p>dns有两种协议，一种是UDP（默认），一种是TCP。</p><h3 id="udp-方式，先回应的数据包被当做有效数据"><a href="#udp-方式，先回应的数据包被当做有效数据" class="headerlink" title="udp 方式，先回应的数据包被当做有效数据"></a>udp 方式，先回应的数据包被当做有效数据</h3><p>在linux下可以用dig来检测dns。国内的DNS服务器通常不会返回正常的结果。<br>下面以google的8.8.8.8 dns服务器来做测试，并用wireshark来抓包，分析结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @8.8.8.8  www.youtube.com</span><br></pre></td></tr></table></figure><p><img src="/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/dns-udp-youtube-badresponse-fast.png" alt="dns-udp-youtube"></p><p>从wireshark的结果，可以看到返回了三个结果，<strong>前面两个是错误的，后面的是正确的</strong>。</p><p>但是，对于dns客户端来说，它只会取最快回应的的结果，后面的正确结果被丢弃掉了。<strong>因为中间被插入了污染包，所以即使我们配置了正确的dns服务器，也解析不到正确的IP。</strong></p><h3 id="tcp-方式，有时有效，可能被rest"><a href="#tcp-方式，有时有效，可能被rest" class="headerlink" title="tcp 方式，有时有效，可能被rest"></a>tcp 方式，有时有效，可能被rest</h3><p>再用TCP下的DNS来测试下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @8.8.8.8 +tcp   www.youtube.com</span><br></pre></td></tr></table></figure><p><img src="/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/dns-tcp-youtube-reset.png" alt="dns-tcp-youtube-reset"></p><p>从wireshark的结果，可以看出在TCP三次握手成功时，本地发出了一个查询<a href="http://www.youtube.com的dns请求,结果,很快收到了一个rst回应.而rst回应是在tcp连接断开时,才会发出的.琥砪,ꣿ戆*桮殘ꑿ桊*珿篰戆晍琥篣殚烣t簚cp栯ꤾ扵扵憩筢,dꒊ躄晍냻n戅禯璛管s憩rs砠t,莔,筢硞昍懖銬退殗興晌跴與杀煃殙祳.*/">www.youtube.com的dns请求，结果，很快收到了一个RST回应。而RST回应是在TCP连接断开时，才会发出的。所以可以看出，*<em>TCP通讯受到了干扰，DNS客户端因为收到RST回应，认为对方断开了连接，因此也无法收到后面正确的回应数据包了。</em></a>*</p><p>再来看下解析twitter的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @8.8.8.8 +tcp  www.twitter.com</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.twitter.com.        590     IN      CNAME   twitter.com.</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.7 80</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.7</span><br><span class="line">twitter.com.            20      IN      A       199.59.149.230</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.39</span><br></pre></td></tr></table></figure><p>这次返回的IP是正确的。但是尝试用telnet 去连接时，会发现连接不上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 199.59.150.7 80</span><br></pre></td></tr></table></figure><p>但是，在国外服务器去连接时，可以正常连接，完成一个http请求。<strong>可见一些IP的访问被禁止了</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 199.59.150.7 80</span><br><span class="line">Trying 199.59.150.7...</span><br><span class="line">Connected to 199.59.150.7.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">HOST:www.twitter.com</span><br><span class="line"></span><br><span class="line">HTTP/1.0 301 Moved Permanently</span><br><span class="line">content-length: 0</span><br><span class="line">date: Sun, 08 Feb 2015 06:28:08 UTC</span><br><span class="line">location: https://www.twitter.com/</span><br><span class="line">server: tsa_a</span><br><span class="line">set-cookie: guest_id=v1%3A142337688883648506; Domain=.twitter.com; Path=/; Expires=Tue, 07-Feb-2017 06:28:08 UTC</span><br><span class="line">x-connection-hash: 0f5eab0ea2d6309109f15447e1da6b13</span><br><span class="line">x-response-time: 2</span><br></pre></td></tr></table></figure><h3 id="黑名单-x2F-白名单"><a href="#黑名单-x2F-白名单" class="headerlink" title="黑名单&#x2F;白名单"></a>黑名单&#x2F;白名单</h3><p>想要获取到正确的IP，自然的黑名单&#x2F;白名单两种思路。</p><p>下面列出一些相关的项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/holmium/dnsforwarder</span><br><span class="line">https://code.google.com/p/huhamhire-hosts/</span><br><span class="line">https://github.com/felixonmars/dnsmasq-china-list</span><br></pre></td></tr></table></figure><h3 id="本地DNS软件"><a href="#本地DNS软件" class="headerlink" title="本地DNS软件"></a>本地DNS软件</h3><ul><li>修改hosts文件<br>相信大家都很熟悉，也有一些工具可以自动更新hosts文件的。</li><li>浏览器pac文件<br>主流浏览器或者其插件，都可以配置pac文件。pac文件实际上是一个JS文件，可以通过编程的方式来控制dns解析结果。其效果类似hosts文件，不过pac文件通常都是由插件控制自动更新的。只能控制浏览器的dns解析。</li><li>本地dns服务器，dnsmasq<br>在linux下，可以自己配置一个dnsmasq服务器，然后自己管理dns。不过比较高级，也比较麻烦。</li></ul><p>顺便提一下，实际上，kubuntu的NetworkManager会自己启动一个私有的dnsmasq进程来做dns解析。不过它侦听的是127.0.1.1，所以并不会造成冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/dnsmasq --no-resolv --keep-in-foreground --no-hosts --bind-interfaces --pid-file=/run/sendsigs.omit.d/network-manager.dnsmasq.pid --listen-address=127.0.1.1 --conf-file=/var/run/NetworkManager/dnsmasq.conf</span><br></pre></td></tr></table></figure><h3 id="路由器智能DNS"><a href="#路由器智能DNS" class="headerlink" title="路由器智能DNS"></a>路由器智能DNS</h3><p>基于OpenWRT&#x2F;Tomoto的路由器可以在上面配置dns server，从而实现在路由器级别智能dns解析。现在国内的一些路由器是基于OpenWRT的，因此支持配置dns服务器。<br>参考项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/clowwindy/ChinaDNS</span><br></pre></td></tr></table></figure><h2 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http proxy"></a>http proxy</h2><h3 id="http-proxy请求和没有proxy的请求的区别"><a href="#http-proxy请求和没有proxy的请求的区别" class="headerlink" title="http proxy请求和没有proxy的请求的区别"></a>http proxy请求和没有proxy的请求的区别</h3><p>在chrome里没有设置http proxy的请求头信息是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /nocache/fesplg/s.gif</span><br><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure><p>在设置了http proxy之后，发送的请求头是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.baidu.com//nocache/fesplg/s.gif</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br></pre></td></tr></table></figure><p>区别是配置http proxy之后，会在请求里发送完整的url。</p><p>client在发送请求时，如果没有proxy，则直接发送path，如果有proxy，则要发送完整的url。</p><p>实际上http proxy server可以处理两种情况，即使客户端没有发送完整的url，因为host字段里，已经有host信息了。</p><p>为什么请求里要有完整的url？</p><p>历史原因。</p><h3 id="目标服务器能否感知到http-proxy的存在？"><a href="#目标服务器能否感知到http-proxy的存在？" class="headerlink" title="目标服务器能否感知到http proxy的存在？"></a>目标服务器能否感知到http proxy的存在？</h3><p>当我们使用http proxy时，有个问题可能会关心的：目标服务器能否感知到http proxy的存在？</p><p>一个配置了proxy的浏览器请求头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http://55.75.138.79:9999/ HTTP/1.1</span><br><span class="line">Host: 55.75.138.79:9999</span><br><span class="line">Proxy-Connection: keep-alive</span><br></pre></td></tr></table></figure><p>实际上目标服务器接收到的信息是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 55.75.138.79:9999</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>可见，http proxy服务器并没有把proxy相关信息发送到目标服务器上。</p><p>因此，目标服务器是没有办法知道用户是否使用了http proxy。</p><h3 id="http-proxy-keep-alive"><a href="#http-proxy-keep-alive" class="headerlink" title="http proxy keep-alive"></a>http proxy keep-alive</h3><p>实际上Proxy-Connection: keep-alive这个请求头是错误的，不在标准里：</p><p>因为http1.1 默认就是Connection: keep-alive</p><p>如果client想要http proxy在请求之后关闭connection，可以用Proxy-Connection: close 来指明。</p><p><a href="http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/web-proxy-connection-header.html">http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/web-proxy-connection-header.html</a></p><h3 id="http-proxy-authentication"><a href="#http-proxy-authentication" class="headerlink" title="http proxy authentication"></a>http proxy authentication</h3><p>当http proxy需要密码时：</p><p>第一次请求没有密码，则会回应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 407 Proxy authentication required</span><br><span class="line">Proxy-Authenticate: Basic realm=&quot;Polipo&quot;</span><br></pre></td></tr></table></figure><p>浏览器会弹出窗口，要求输入密码。<br>如果密码错误的话，回应头是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 407 Proxy authentication incorrect</span><br></pre></td></tr></table></figure><p>如果是配置了密码，发送的请求头则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.baidu.com/ HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Proxy-Authorization: Basic YWRtaW46YWRtaW4=</span><br></pre></td></tr></table></figure><p>Proxy-Authorization实际是Base64编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64(&quot;admin:admin&quot;) == &quot;YWRtaW46YWRtaW4=&quot;</span><br></pre></td></tr></table></figure><h3 id="http-proxy对于不认识的header和方法的处理："><a href="#http-proxy对于不认识的header和方法的处理：" class="headerlink" title="http proxy对于不认识的header和方法的处理："></a>http proxy对于不认识的header和方法的处理：</h3><p>http proxy通常会尽量原样发送，因为很多程序都扩展了http method，如果不支持，很多程序都不能正常工作。</p><p>客户端用OPTIONS 请求可以探测服务器支持的方法。但是意义不大。</p><h2 id="https-proxy"><a href="#https-proxy" class="headerlink" title="https proxy"></a>https proxy</h2><p>当访问一个https网站时，<a href="https://github.com/">https://github.com</a></p><p>先发送connect method，如果支持，会返回200</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONNECT github.com:443 HTTP/1.1</span><br><span class="line">Host: github.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h3 id="http-tunnel"><a href="#http-tunnel" class="headerlink" title="http tunnel"></a>http tunnel</h3><p><a href="http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling">http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling</a></p><p>通过connect method，http proxy server实际上充当tcp转发的中间人。<br>比如，用nc 通过http proxy来连42端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -x10.2.3.4:8080 -Xconnect host.example.com 42</span><br></pre></td></tr></table></figure><p>原理是利用CONNECT方法，让http proxy服务器充当中间人。</p><h3 id="https-proxy的安全性？"><a href="#https-proxy的安全性？" class="headerlink" title="https proxy的安全性？"></a>https proxy的安全性？</h3><p>proxy server可以拿到什么信息？</p><p>通过一个http proxy去访问支付宝是否安全？</p><ul><li>可以知道host，即要访问的是哪个网站</li><li>拿不到url信息</li><li>https协议保证不会泄露通信内容</li><li>TLS(Transport Layer Security) 在握手时，生成强度足够的随机数</li><li>TLS 每一个record都要有一个sequence number，每发一个增加一个，并且是不能翻转的。</li><li>TLS 保证不会出现重放攻击</li></ul><p>TLS的内容很多，这里说到关于安全的一些关键点。</p><p>注意事项：</p><ul><li>确保是https访问</li><li>确保访问网站的证书没有问题</li></ul><p>是否真的安全了？更强的攻击者！</p><p>流量劫持 —— 浮层登录框的隐患</p><p><a href="http://fex.baidu.com/blog/2014/06/danger-behind-popup-login-dialog/">http://fex.baidu.com/blog/2014/06/danger-behind-popup-login-dialog/</a></p><p><strong>所以，尽量不要使用来路不明的http&#x2F;https proxy，使用公开的wifi也要小心。</strong></p><h2 id="goagent工作原理"><a href="#goagent工作原理" class="headerlink" title="goagent工作原理"></a>goagent工作原理</h2><ul><li>local http&#x2F;https proxy</li><li>伪造https证书，导入浏览器信任列表里</li><li>浏览器配置http&#x2F;https proxy</li><li>解析出http&#x2F;https request的内容。然后把这些请求内容打包，发给GAE服务器</li><li>与GAE通信通过http&#x2F;https，内容用RC4算法加密</li><li>GAE服务器，再调用google提供的 urlfetch，来获得请求的回应，然后再把回应打包，返回给客户端。</li><li>客户端把回应传给浏览器</li><li>自带dns解析服务器</li><li>在local&#x2F;certs&#x2F; 目录下可以找到缓存的伪造的证书</li></ul><p>fiddler抓取https数据包是同样原理。</p><p>goagent会为每一个https网站伪造一个证书，并缓存起来。比如下面这个github的证书：<br><img src="/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/goagent-github-cert.png" alt="goagent-github-cert.png"></p><p>goagent的代码在3.0之后，支持了很多其它功能，变得有点混乱了。</p><p>以3.2.0 版本为例：</p><p>主要的代码是在server&#x2F;gae&#x2F;gae.py 里。<br><a href="https://github.com/goagent/goagent/blob/v3.2.0/server/gae/gae.py#L107">https://github.com/goagent/goagent/blob/v3.2.0/server/gae/gae.py#L107</a></p><p>一些代码实现的细节：</p><ul><li>支持最长的url是2083，因为gae sdk的限制。<br><a href="https://github.com/AppScale/gae_sdk/blob/master/google/appengine/api/taskqueue/taskqueue.py#L241">https://github.com/AppScale/gae_sdk/blob/master/google/appengine/api/taskqueue/taskqueue.py#L241</a></li><li>如果回应的内容是&#x2F;text, json, javascript，且 &gt; 512会用gzip来压缩</li><li>处理一些Content-Range 的回应内容。Content-Range 的代码虽然只有一点点，但是如果是不熟悉的话，要花上不少工夫。</li><li>goagent的生成证书的代码在 local&#x2F;proxylib.py的这个函数里：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def _get_cert(commonname, sans=()):</span><br></pre></td></tr></table></figure><h3 id="为什么goagent可以看视频？"><a href="#为什么goagent可以看视频？" class="headerlink" title="为什么goagent可以看视频？"></a>为什么goagent可以看视频？</h3><p>因为很多网站都是http协议的。有少部分是rmtp协议的，也有是rmtp over http的。</p><p>在youku看视频的一个请求数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http://14.152.72.22/youku/65748B784A636820C5A81B41C7/030002090454919F64A167032DBBC7EE242548-46C9-EB9D-916D-D8BA8D5159D3.flv?&amp;start=158</span><br><span class="line">response：</span><br><span class="line">Connection:close</span><br><span class="line">Content-Length:7883513</span><br><span class="line">Content-Type:video/x-flv</span><br><span class="line">Date:Wed, 17 Dec 2014 17:55:24 GMT</span><br><span class="line">ETag:&quot;316284225&quot;</span><br><span class="line">Last-Modified:Wed, 17 Dec 2014 15:21:26 GMT</span><br><span class="line">Server:YOUKU.GZ</span><br></pre></td></tr></table></figure><p>可以看到，有ETag，有长度信息等。</p><h3 id="goagent缺点"><a href="#goagent缺点" class="headerlink" title="goagent缺点"></a>goagent缺点</h3><ul><li>只是http proxy，不能代理其它协议</li><li>google的IP经常失效</li><li>不支持websocket协议</li><li>配置复杂</li></ul><h2 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h2><h3 id="流行的vpn类型"><a href="#流行的vpn类型" class="headerlink" title="流行的vpn类型"></a>流行的vpn类型</h3><ul><li>PPTP，linux pptpd，安全性低，不能保证数据完整性或者来源，MPPE加密暴力破解</li><li>L2TP，linux xl2tpd，预共享密钥可以保证安全性</li><li>SSTP，基于HTTPS，微软提出。linux开源实现SoftEther VPN</li><li>OPENVPN，基于SSL，预共享密钥可以保证安全性</li><li>所谓的SSL VPN，各家厂商有自己的实现，没有统一的标准</li><li>新型的staless VPN，像sigmavpn&#x2F;ShadowVPN等</li></ul><p>现状：</p><ul><li>PPTP&#x2F;L2TP 可用，但可能会不管用</li><li>SoftEther VPN&#x2F;OPENVPN 可能会导致服务器被封IP，连不上，慎用</li><li>ShadowVPN可用，sigmavpn没有测试</li></ul><p>猜测下为什么PPTP，L2TP这些方案容易被检测到？</p><p>可能是因为它们的协议都有明显的标头：</p><ul><li>转发的是ppp协议数据，握手有特征</li><li>PPTP协议有GRE标头和PPP标头</li><li>L2TP有L2TP标头和PPP标头</li><li>L2TP要用到IPsec</li></ul><p>参考：</p><p><a href="https://technet.microsoft.com/zh-cn/library/cc771298(v=ws.10).aspx">https://technet.microsoft.com/zh-cn/library/cc771298(v=ws.10).aspx</a></p><h3 id="网页版的SSL-VPN"><a href="#网页版的SSL-VPN" class="headerlink" title="网页版的SSL VPN"></a>网页版的SSL VPN</h3><p>有些企业，或者学校里，会有这种VPN：</p><ul><li>网页登陆帐号</li><li>设置IE代理，为远程服务器地址</li><li>通过代理浏览内部网页</li></ul><p>这种SSL VPN原理很简单，就是一个登陆验证的http proxy，其实并不能算是VPN？</p><h3 id="新型的staless-vpnVPN，sigmavpn-x2F-ShadowVPN"><a href="#新型的staless-vpnVPN，sigmavpn-x2F-ShadowVPN" class="headerlink" title="新型的staless vpnVPN，sigmavpn&#x2F;ShadowVPN"></a>新型的staless vpnVPN，sigmavpn&#x2F;ShadowVPN</h3><p>这种新型VPN的原理是，利用虚拟的网络设备TUN和TAP，把请求数据先发给虚拟设备，然后把数据加密转发到远程服务器。（VPN都这原理？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you &lt;-&gt; local &lt;-&gt; protocol &lt;-&gt; remote &lt;-&gt; ...... &lt;-&gt; remote &lt;-&gt; protocol &lt;-&gt; local &lt;-&gt; peer</span><br></pre></td></tr></table></figure><p>这种新型VPN的特点是很轻量，没有传统VPN那么复杂的握手加密控制等，而向个人，而非企业。SigmaVPN号称只有几百行代码。</p><p>参考：</p><p><a href="http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP">http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP</a></p><p><a href="https://code.google.com/p/sigmavpn/wiki/Introduction">https://code.google.com/p/sigmavpn/wiki/Introduction</a></p><h3 id="ubuntu-pptp-vpn-server安装"><a href="#ubuntu-pptp-vpn-server安装" class="headerlink" title="ubuntu pptp vpn server安装"></a>ubuntu pptp vpn server安装</h3><p>ubuntu官方参考文档：<br><a href="https://help.ubuntu.com/community/PPTPServer">https://help.ubuntu.com/community/PPTPServer</a></p><ul><li><p>vps 要开启ppp和nat网络转发的功能</p></li><li><p><strong>设置MTU，建议设置为1200以下</strong>，因为中间网络可能很复杂，MTU太大可能导致连接失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p tcp --syn -s 192.168.0.0/24 -j TCPMSS --set-mss 1200</span><br></pre></td></tr></table></figure></li></ul><h2 id="socks-proxy"><a href="#socks-proxy" class="headerlink" title="socks proxy"></a>socks proxy</h2><ul><li>rfc 文档： <a href="http://tools.ietf.org/html/rfc1928">http://tools.ietf.org/html/rfc1928</a></li><li>wiki上的简介： <a href="http://en.wikipedia.org/wiki/SOCKS#SOCKS5">http://en.wikipedia.org/wiki/SOCKS#SOCKS5</a></li><li>socks4&#x2F;socks4a 已经过时</li><li>socks5</li></ul><p>socks5支持udp，所以如果客户端把dns查询也走socks的话，那么就可以直接解决dns的问题了。</p><h3 id="socks-proxy-握手的过程"><a href="#socks-proxy-握手的过程" class="headerlink" title="socks proxy 握手的过程"></a>socks proxy 握手的过程</h3><p>socks5流程</p><ul><li>客户端查询服务器支持的认证方式</li><li>服务器回应支持的认证方式</li><li>客户端发送认证信息，服务器回应</li><li>如果通过，客户端直接发送TCP&#x2F;UDP的原始数据，以后proxy只单纯转发数据流，不做任何处理了</li><li><strong>socks proxy 自身没有加密机制，简单的TCP&#x2F;UDP forward</strong></li></ul><p>socks协议其实是相当简单的，用wireshark抓包，结合netty-codec-socks，很容易可以理解其工作过程。<br><a href="https://github.com/netty/netty/tree/master/codec-socks">https://github.com/netty/netty/tree/master/codec-socks</a></p><h3 id="ssh-socks-proxy"><a href="#ssh-socks-proxy" class="headerlink" title="ssh socks proxy"></a>ssh socks proxy</h3><p>如果有一个外国的服务器，可以通过ssh连接登陆，那么可以很简单地搭建一个本地的socks5代理。</p><p>XShell可以通过“转移规则”来配置本地socks服务器，putty也有类似的配置：<br><img src="/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/xshell-sock5-proxy.png" alt="xshell-sock5-proxy.png"></p><p>linux下命令行启动一个本地sock5服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 user@romoteHost</span><br></pre></td></tr></table></figure><p>ssh还有一些端口转发的技巧，这对于测试网络程序，绕过防火墙也是很有帮助的。</p><p>参考：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p><h3 id="shadowsocks的工作原理"><a href="#shadowsocks的工作原理" class="headerlink" title="shadowsocks的工作原理"></a>shadowsocks的工作原理</h3><p>shadowsocks是非常流行的一个代理工具，其原理非常简单。</p><ul><li>客户端服务器预共享密码</li><li>本地socks5 proxy server（有没有想起在学校时用的ccproxy？）</li><li>软件&#x2F;浏览器配置本地socks代理</li><li>本地socks server把数据包装，AES256加密，发送到远程服务器</li><li>远程服务器解密，转发给对应的服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app =&gt; local socks server(encrypt) =&gt; shadowsocks server(decrypt) =&gt; real host</span><br><span class="line"></span><br><span class="line">app &lt;= (decrypt) local socks server &lt;= (encrypt) shadowsocks server &lt;= real host</span><br></pre></td></tr></table></figure><p>其它的一些东东：</p><ul><li>一个端口一个密码，没有用户的概念</li><li>支持多个worker并发</li><li>协议简单，比socks协议还要简单，抽取了socks协议的部分</li></ul><h3 id="shadowsoks的优点"><a href="#shadowsoks的优点" class="headerlink" title="shadowsoks的优点"></a>shadowsoks的优点</h3><ul><li>中间没有任何握手的环节，直接是TCP数据流</li><li>速度快</li></ul><h3 id="shadowsocks的安全性"><a href="#shadowsocks的安全性" class="headerlink" title="shadowsocks的安全性"></a>shadowsocks的安全性</h3><ul><li>服务器可以解出所有的TCP&#x2F;UDP数据</li><li>中间人攻击，重放攻击</li></ul><p>所以，<strong>对于第三方shadow socks服务器，要慎重使用。</strong></p><p>在使用shadowsocks的情况下，https通迅是安全的，但是仍然有危险，参见上面http proxy安全的内容。</p><h3 id="vpn和socks代理的区别"><a href="#vpn和socks代理的区别" class="headerlink" title="vpn和socks代理的区别"></a>vpn和socks代理的区别</h3><p>从原理上来说，socks代理会更快，因为转发的数据更少。</p><p>因为vpn转发的是ppp数据包，ppp协议是数据链路层(data link layer)的协议。socks转发的是TCP&#x2F;UDP数据，是传输(transport)层。</p><p>VPN的优点是很容易配置成全局的，这对于很多不能配置代理的程序来说很方便。而配置全局的socks proxy比较麻烦，目前貌似还没有简单的方案。</p><h3 id="linux下一些软件配置代理的方法"><a href="#linux下一些软件配置代理的方法" class="headerlink" title="linux下一些软件配置代理的方法"></a>linux下一些软件配置代理的方法</h3><ul><li>bash&#x2F;shell</li></ul><p>对于shell，最简单的办法是在命令的前面设置下http_porxy的环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://127.0.0.1:8123 wget http://test.com</span><br></pre></td></tr></table></figure><p>推荐的做法是在~&#x2F;.bashrc 文件里设置两个命令，开关http proxy：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias proxyOn=&#x27;export https_proxy=http://127.0.0.1:8123 &amp;&amp; http_proxy=http://127.0.0.1:8123&#x27;</span><br><span class="line">alias proxyOff=&#x27;unset https_proxy &amp;&amp; unset  http_proxy&#x27;</span><br></pre></td></tr></table></figure><p>注意，如果想sudo的情况下，http proxy仍然有效，要配置env_keep。</p><p>在&#x2F;etc&#x2F;sudoers.d&#x2F;目录下增加一个env_keep的文件，内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults env_keep += &quot; http_proxy https_proxy ftp_proxy &quot;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://help.ubuntu.com/community/AptGet/Howto#Setting_up_apt-get_to_use_a_http-proxy">https://help.ubuntu.com/community/AptGet/Howto#Setting_up_apt-get_to_use_a_http-proxy</a></p><ul><li>GUI软件</li></ul><p>现在大部分软件都可以设置代理。<br>gnome和kde都可以设置全局的代理。</p><h3 id="linux下不支持代理的程序使用socks代理：tsocks"><a href="#linux下不支持代理的程序使用socks代理：tsocks" class="headerlink" title="linux下不支持代理的程序使用socks代理：tsocks"></a>linux下不支持代理的程序使用socks代理：tsocks</h3><p>tsocks利用LD_PRELOAD机制，代理程序里的connect函数，然后就可以代理所有的TCP请求了。<br>不过dns请求，默认是通过udp来发送的，所以tsocks不能代理dns请求。</p><p>默认情况下，tsocks会先加载~&#x2F;.tsocks.conf，如果没有，再加载&#x2F;etc&#x2F;tsocks.conf。对于local ip不会代理。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tsocks</span><br><span class="line">LD_PRELOAD=/usr/lib/libtsocks.so wget http://www.facebook.com</span><br></pre></td></tr></table></figure><h2 id="基于路由器的方案"><a href="#基于路由器的方案" class="headerlink" title="基于路由器的方案"></a>基于路由器的方案</h2><p>基于路由器的方案有很多，原理和本机的方案是一样的，只不过把这些措施前移到路由器里。</p><p>路由器的方案的优点是很明显的：</p><ul><li>手机&#x2F;平板不用设置</li><li>公司&#x2F;局域网级的代理</li></ul><p>但是需要专门的路由器，刷固件等。</p><p>shadowsocks, shadowvpn都可以跑在路由器上。</p><p>一些项目收集：</p><p><a href="https://github.com/lifetyper/FreeRouter_V2">https://github.com/lifetyper/FreeRouter_V2</a></p><p><a href="https://gist.github.com/wen-long/8644243">https://gist.github.com/wen-long/8644243</a></p><p><a href="https://github.com/ashi009/bestroutetb">https://github.com/ashi009/bestroutetb</a></p><h2 id="推荐的办法"><a href="#推荐的办法" class="headerlink" title="推荐的办法"></a>推荐的办法</h2><p>完全免费</p><ul><li>chrome + switchsharp&#x2F;SwitchyOmega + http proxy</li><li>goagent</li></ul><p>程序员的推荐</p><ul><li>chrome + switchsharp&#x2F;SwitchyOmega + socks5 proxy</li><li>aws免费一年的服务器&#x2F;其它国外免费云主机，节点位置决定速度，推荐东京机房</li><li>shadowsocks</li></ul><p>第三方免费的服务器</p><ul><li>shadowsocks服务器，微信公众号：pennyjob</li></ul><p>手机软件：</p><ul><li>fqrouter</li><li>shadowsocks client</li></ul><p>商业软件安全性自己考虑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>新技术层出不穷</li><li>越流行，越容易失效</li><li>实现一个proxy其实相当简单</li><li>知其所以然，更好使用工具，也可以创作出自己的工具。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Tor原理以及漏洞详解~</title>
    <link href="http://example.com/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-22T08:15:26.000Z</published>
    <updated>2023-02-22T08:22:18.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Tor原理以及漏洞详解（一）"><a href="#Tor原理以及漏洞详解（一）" class="headerlink" title="Tor原理以及漏洞详解（一）"></a>Tor原理以及漏洞详解（一）</h3><p><strong>【PConline 杂谈】</strong>拥有250万日常用户的Tor网络是世界上最受互联网用户欢迎的匿名系统，十多年来，生活在监控下的人们已经习惯用Tor在电子监控和网页寄存内容中隐藏他们的浏览习惯。可以安全的从网络服务中隐藏自己一度被人们认为是具有颠覆性的。然而最近有研究人员证明Tor似乎也不是那么安全。</p><p>　　在麻省理工学院和卡塔尔计算研究所的研究人员（QCRI）已经证明在Tor上存在设计漏洞。在今年夏天的USENIX安全研讨会上，他们表示，通过分析志愿人员在独立电脑上的Tor网络上进行加密数据的传输，攻击者可以推断出隐藏<a href="https://servers.pconline.com.cn/">服务器</a>的位置，或者通过信息源找到指定的Tor用户信息。</p><p>　　谈到Tor的漏洞还是要从Tor是什么以及他的运行原理说起。</p><p>　　<strong>层层包裹的Tor</strong></p><p>　　Tor（The Onion Router，洋葱<a href="https://product.pconline.com.cn/router/">路由器</a>）由已经安装了Tor软件的电脑连接网络而成。它之所以被称为onion，是因为它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开。即每个<a href="https://product.pconline.com.cn/router/">路由</a>器间的传输都经过点对点密钥（symmetric key）来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式。</p><p>　　举个例子，假如一个Tor用户想匿名浏览《纽约时报》的头版，他的计算机将把Web请求包裹在几层加密中随机发送到另一个具有Tor功能的电脑。这台电脑被称为guard，guard在剥离掉当前第一层加密后将继续随机转发至网络中的另一台计算机，之后的计算机再剥离一层然后转发，以此循环反复。</p><p>　　整个链中的最后一台计算机，称为出口节点（exit node），剥离最后一层加密后，露出请求的真正终点：《纽约时报》。第一台计算机知道发送者的网络地址，出口知道目标站点的网络地址，但在该链中没有一台电脑知道完整的信息。这个经过层层加密的路由方案，就是Tor。</p><p><img src="/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/1.jpg" alt="1"></p><p>　　用 Tor 创建一条私有网络路径时，用户的软件或客户端通过网络上的中继递增地建立一条由若干加密连接组成的环路（circuit）。环路一次扩展一跳（hop），环路上的中继仅仅知道它从哪一个中继接收数据以及向哪一个中继发送数据。没有一台单独的中继会知道数据包的完整路径。客户端与环路上的每一跳都协商一组独立的密钥，这样可以保证数据通过任何一跳时都无法跟踪。</p><h3 id="Tor原理以及漏洞详解（二）"><a href="#Tor原理以及漏洞详解（二）" class="headerlink" title="Tor原理以及漏洞详解（二）"></a>Tor原理以及漏洞详解（二）</h3><p>　　除了匿名上网浏览，Tor 同样使用户能够在隐藏自身位置的前提下提供各类服务，例如 Web 发布和及时通讯<a href="https://servers.pconline.com.cn/">服务器</a>。其他 Tor 用户使用 Tor 的“聚合点”（rendezvous points）连接到这些隐匿服务，互相都不知道对方的网络标识。Tor 用户能够使用这项隐匿服务功能建立网站，人们在网站上发布资料而不用担心遭到审查。没人能够确认到底是谁在运行网站，网站的运行者也不知道到底是谁发布了资料。例如，伊朗有人创建一个网站来存放西方媒体新闻报道，但是并不想让人找到。因此他使用了Tor软件，Tor的主机电脑，用introduction points（介绍点）来满足所有想要访问这些内容的人，通过这些introduction points这个地址人们可以访问这个隐藏网络，但是却没有人能找到他的真实位置。</p><p><img src="/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/2.jpg" alt="2"></p><p>　　了解了Tor是什么，以及它的原理后，我们再来看看Tor是如何收到攻击的吧。</p><p>　　既然guard被随机选择，那么如果攻击者连接到Tor网络上面足够多的电脑，就有很高的几率，在某些情况下，能够成功的窥探到他们其中的一个或者几个。</p><p>　　一个电路的建立过程中，Tor网络上的计算机们将大量的来回的传递数据。研究人员发现，通过一个guard可以很简单的找到在各个方向上传递的数据包流量。利用机器学习算法，就能以99%的准确率分辨出这是一个普通的网页环路，introduction-point circuit还是一个rendezvous-point。因此并不需要打破Tor的加密。</p><p><img src="/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/3.jpg" alt="3"></p><p>　　此外通过使用Tor的电脑连接到一系列不同的隐藏服务，他们表明，类似于流量分析模式可以以88%的准确率确定这些服务。这意味着一个幸运的攻击者进入到了隐藏服务的guard的位置时，它将有88%的把握，确定它就是该隐藏服务的主机。</p><p>　　同样，一个幸运的间谍进入到guard位置，那么他有百分之88的准确率，发现哪些网站被用户访问过。因此环路（circuit）的指纹是Tor隐藏服务的一大隐患。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>上网限制和翻墙的基本原理</title>
    <link href="http://example.com/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-20T13:20:21.000Z</published>
    <updated>2023-02-22T08:33:14.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文转载自：<a href="http://blog.021xt.cc/archives/85">http://blog.021xt.cc/archives/85</a></p><p>目前在国内基本访问不了google站点和android的站点，下载个gradle都要等很久。所以如果不翻墙很多工作都没办法正常做。所以在学习翻墙的同时也顺便了解了下目前限制网络访问的一些基本知识。</p><p>网络限制和监控应该说大家都有体会。比如很多公司都会限制一些网站的访问，比如网盘、视屏网站。有时也会对你访问的内容进行监控。还有一些公共WIFI，可能限制你只能访问80端口。在比如在国内无法访问google，facebook，android等网站。要想绕过这些限制，必须先知道他们是如何限制的。</p><p>本文主要是从技术角度来了解的网络限制方式和应对方式。并不做任何翻墙方式的推荐和指导。对于网络的知识，还是停留在上过网络课 的水平，文章内容也都是自己了解后总结的。可能会有错误和遗漏。会定期更新。</p><h1 id="DNS污染和劫持"><a href="#DNS污染和劫持" class="headerlink" title="DNS污染和劫持"></a>DNS污染和劫持</h1><p>以下解释来之百度百科：<br>某些<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E5%95%86">网络运营商</a>为了某些目的，对<a href="https://baike.baidu.com/item/dns/427444">DNS</a>进行了某些操作，导致使用<a href="https://baike.baidu.com/item/isp/10152">ISP</a>的正常上网设置无法通过域名取得正确的IP地址。<br>某些国家或地区出于某些目的为了防止某网站被访问，而且其又掌握部分国际DNS根目录服务器或镜像，也会利用此方法进行屏蔽。</p><p>目前我们访问网站主要都是通过域名进行访问，而真正访问这个网站前需要通过DNS服务器把域名解析为IP地址。而普通的DNS服务使用UDP协议，没有任何的认证机制。DNS劫持是指返回给你一个伪造页面的IP地址，DNS污染是返回给你一个不存在的页面的IP地址。</p><p>比如你使用电信、联通、移动的宽带，默认你是不需要设置任何DNS服务器的。这些DNS服务器由他们提供。一旦检测到你访问的网页是不允许的访问的，就会返回一个不存在的网页。而很多运营商也会使用DNS劫持来投放一些广告。</p><p>解决办法：</p><ol><li><p>使用<a href="https://www.opendns.com/setupguide/">OpenDNS</a>（208.67.222.222）或<a href="https://developers.google.com/speed/public-dns/">GoogleDNS</a>（8.8.8.8）（现在不太好用，被封锁，速度慢）</p></li><li><p>使用一些第三方的DNS服务器</p></li><li><p>自己用VPS搭建DNS服务器</p></li><li><p>修改机器host文件，直接IP访问</p></li><li><p>封锁IP</p><p>通过上面一些方式，可以绕过DNS污染，通过IP地址访问无法访问的网页。但是目前针对IP进行大范围的封锁。虽然google这种大公司有很多镜像IP地址，但是目前基本全部被封锁掉，有漏网的可能也坚持不了多久。而且很多小公司的服务是部署在一些第三方的主机上，所以封锁IP有时会误伤，封锁一个IP导致主机上本来可以使用的页面也无法访问了。</p><p>不过目前不可能把所有国外的IP全部封锁掉，所以我们采用机会从国内连接到国外的VPS，进行翻墙。</p><p>解决办法：</p><ol><li>使用VPS搭建代理</li><li>使用IPV6 （IPV6地址巨大，采用封地址不现实，但是目前国内只有部分高校部署了IPV6）</li></ol><h1 id="封锁HTTP代理"><a href="#封锁HTTP代理" class="headerlink" title="封锁HTTP代理"></a>封锁HTTP代理</h1><p>对于没有办法搭建VPS的人来说，最好的办法就是使用HTTP代理。客户端不在直接请求目标服务器，而是请求代理服务器，代理服务器在去请求目标服务器。然后返回结果。关于HTTP代理可以参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《HTTP权威指南》第六章：代理</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png" alt="1"></p><p>对于HTTP代理来说，封锁起来非常简单。因为HTTP协议是明文，Request Message中就带有要请求的URL或IP地址，这样很容易就被检测到。对于HTTPS来说，虽然通信是进行加密了，但是在建连之前会给代理服务器发送CONNECT方法，这里也会带上要访问的远端服务器地址。如果代理服务器在国外，在出去前就会被检测到。 如果代理服务器在国内，呵呵，你也出不去啊。</p><p>对于HTTP代理，因为是明文，所以很容易被服务器了解你的一些数据。<strong>所以不要随便使用第三方的HTTP代理访问HTTP网站，而HTTPS虽然不知道你的数据，但是可以知道你去了那里。</strong></p><p>解决办法：</p><ol><li>使用VPS搭建VPN</li><li>使用第三方VPN</li></ol><h1 id="封锁VPN"><a href="#封锁VPN" class="headerlink" title="封锁VPN"></a>封锁VPN</h1><p><strong>虚拟专用网</strong>（英语：<strong>Virtual Private Network</strong>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网</a>）来传送<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91">内联网</a>的网络讯息。它利用已加密的<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">通道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2.jpg" alt="2"></p><p>正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/3.png" alt="3"></p><p>通常VPN协议都会对数据流进行强加密处理，从而使得第三方无法知道数据内容，这样就实现了翻墙。翻墙时VPN服务器知道你干的所有事情（HTTP，对于HTTPS，它知道你去了哪）。</p><p>VPN有多种协议：OPENVPN、PPTP、L2TP&#x2F;IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。</p><table><thead><tr><th align="left"></th><th align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png" alt="4"></th><th align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png" alt="5"></th><th align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png" alt="6"></th></tr></thead><tbody><tr><td align="left">背景</td><td align="left">PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。</td><td align="left">L2TP 是一个在 IETF <a href="https://tools.ietf.org/html/rfc3193">RFC 3193</a> 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。</td><td align="left">OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL&#x2F;TLS 加密协议。</td></tr><tr><td align="left">数据加密</td><td align="left">PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，<a href="https://en.wikipedia.org/wiki/Microsoft_Point-to-Point_Encryption">MPPE</a>）加密。MPPE 实现了 RSA <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> 加密算法，并使用最长 128 位密钥。</td><td align="left">L2TP 负载使用标准的 IPSec 协议加密。在 <a href="https://tools.ietf.org/html/rfc4835">RFC 4835</a> 中指定了使用 3DES 或 AES 加密算法作为保密方式。</td><td align="left">OpenVPN 使用 <a href="https://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a> 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。</td></tr><tr><td align="left">安装&#x2F;配置</td><td align="left">Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。</td><td align="left">从 2000&#x2F;XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP&#x2F;IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。</td><td align="left">OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。</td></tr><tr><td align="left">速度</td><td align="left">由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。</td><td align="left">L2TP&#x2F;IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。</td><td align="left">当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。</td></tr><tr><td align="left">端口</td><td align="left">PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。</td><td align="left">L2TP&#x2F;IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP&#x2F;IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。</td><td align="left">OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。</td></tr><tr><td align="left">稳定性&#x2F;兼容性</td><td align="left">PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。</td><td align="left">L2TP&#x2F;IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。</td><td align="left">无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。</td></tr><tr><td align="left">安全弱点</td><td align="left">微软实现的 PPTP 有一个严重的安全问题（<a href="https://www.schneier.com/paper-pptpv2.html">serious security vulnerabilities</a>）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“<a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">位翻转攻击（ bit-flipping attack ）</a>”。如果保密是重要的，微软也强烈建议升级到 IPSec。</td><td align="left">IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。</td><td align="left">OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。</td></tr><tr><td align="left">客户端的兼容性</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android</td><td align="left">Windows、Mac OS X、Linux</td></tr><tr><td align="left">结论</td><td align="left">由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP&#x2F;IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP&#x2F;IPSec 值得考虑。</td><td align="left">L2TP&#x2F;IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP&#x2F;IPSec 也是一个较佳的选择。</td><td align="left">对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。</td></tr><tr><td align="left">等级</td><td align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/7.png" alt="7"></td><td align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/8.png" alt="8"></td><td align="left"><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/9.png" alt="9"></td></tr></tbody></table><p>对于VPN和其他一些加密的传输的协议来说，没有办法直接获取明文的请求信息，所以没有办法直接封锁，而是使用了监控的方式：</p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>对于一些使用弱加密方式的协议来说，直接使用暴力破解检查传输内容。比如PPTP使用MPPE加密，但是MPPE是基于RC4，对于强大的防火墙背后的超级计算机集群，破解就是几秒钟的事情。</p><p>破解后明文中一旦包含了违禁内容，请求就会被封。而对应的IP可能会进入重点关怀列表。</p><h2 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h2><p>要想成功翻墙都必须与对应的远程服务器建立连接，然后再用对应的协议进行数据处理并传输。<br>而问题就出在这里：翻墙工具和远程服务器建立连接时，如果表现的很独特，在一大堆流量里很显眼，就会轻易被GFW识别出从而直接阻断连接，而VPN（尤其是OPENVPN）和SSH这方面的问题尤其严重。</p><h2 id="流量监控"><a href="#流量监控" class="headerlink" title="流量监控"></a>流量监控</h2><p>当一个VPN地址被大量人请求，并保持长时间连接时，就很容易引起关注。SSH接口有大量数据请求。一般会结合其他特征。</p><h2 id="深度包检测"><a href="#深度包检测" class="headerlink" title="深度包检测"></a>深度包检测</h2><p><strong>深度数据包检测</strong>（英语：Deep packet inspection，缩写为 DPI），又称<strong>完全数据包探测</strong>（complete packet inspection）或<strong>信息萃取</strong>（Information eXtraction，IX），是一种电脑网络数据包过滤技术，用来检查通过检测点之<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E5%B0%81%E5%8C%85">数据包</a>的数据部分（亦可能包含其<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%A4%B4">标头</a>），以搜索不匹配规范之协议、病毒、垃圾邮件、入侵，或以预定之准则来决定数据包是否可通过或需被路由至其他不同目的地，亦或是为了收集统计数据之目的。</p><p>比如我们用HTTPS来访问一个网站，TLS&#x2F;SSL协议在建连过程如下：</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/10.gif" alt="10"></p><p>很明显的会发送“client hello”和“server hello” 这种特诊很明显的信息。（当然不会根据这个就封掉，否则https没法用了）。而后续会有服务端证书发送，验证，客户端密钥协商等过程。有明显的协议特征。</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/11.png" alt="11"></p><p>下面是网上找的两张图：<strong>提醒大家最好不要随便用不安全的VPN来访问不合适的网页</strong>，开开android没啥问题。</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/12.png" alt="12"></p><h1 id="Socks代理-x2F-SSH-Socks"><a href="#Socks代理-x2F-SSH-Socks" class="headerlink" title="Socks代理&#x2F;SSH Socks"></a>Socks代理&#x2F;SSH Socks</h1><p><strong>SOCKS</strong>是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKetS”的缩写[1]。<br>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。<br>这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版本相比，增加支持UDP、验证，以及IPv6。<br>根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间</p><h2 id="与HTTP代理的对比"><a href="#与HTTP代理的对比" class="headerlink" title="与HTTP代理的对比"></a>与HTTP代理的对比</h2><p>SOCKS工作在比HTTP代理更低的层次：SOCKS使用握手协议来通知代理软件其客户端试图进行的连接SOCKS，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。虽然HTTP代理有不同的使用模式，CONNECT方法允许转发TCP连接；然而，SOCKS代理还可以转发UDP流量和<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理</a>，而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）</p><p>Socks代理本身协议是明文传输，虽然相对HTTP有一些优势，但是明文也导致Socks代理很容易被封。所以可以考虑对Socks进行加密。所以出现了SSH Socks，对于MAC和Linux来说，不需要Client就可以进行访问。详细可以看：<a href="https://my.oschina.net/leejun2005/blog/94401">SSH隧道技术简介：端口转发&amp;SOCKS代理</a></p><p>但是网上看有些地区好像会对一些VPS的SSH进行端口干扰。我在武汉好像SSH到我的VPS一会就会断。在上海一直没这问题。而且SSH一般是小流量数据，如果数据量特别大，也会被认为是翻墙，进入特别关怀列表。</p><h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p><strong>认准官网：</strong><a href="https://shadowsocks.org/en/index.html">https://shadowsocks.org/en/index.html</a> <strong>（.com那个是卖账号的）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A secure socks5 proxy,</span><br><span class="line">designed to protect your Internet traffic.</span><br></pre></td></tr></table></figure><p>Shadowsocks 目前不容易被封杀主要是因为：</p><ol><li>建立在socks5协议之上，socks5是运用很广泛的协议，所以没办法直接封杀socks5协议</li><li>使用socks5协议建立连接，而没有使用VPN中的服务端身份验证和密钥协商过程。而是在服务端和客户端直接写死密钥和加密算法。所以防火墙很难找到明显的特征，因为这就是个普通的socks5协议。</li><li>Shadowsock搭建也比较简单，所以很多人自己架设VPS搭建，个人使用流量也很小，没法通过流量监控方式封杀。</li><li>自定义加密方式和密钥。因为加密主要主要是防止被检测，所以要选择安全系数高的加密方式。之前RC4会很容易被破解，而导致被封杀。所以现在推荐使用AES加密。而在客户端和服务端自定义密钥，泄露的风险相对较小。</li></ol><p><strong>所以如果是自己搭建的Shadosocks被封的概率很小，但是如果是第三方的Shadeowsocks，密码是server定的，你的数据很可能遭受到中间人攻击。</strong></p><p>顺便说一下，Shadowssocks是天朝的clowwindy大神写的。不过Shadowsocks项目源码已经从github上删除了并停止维护了，但是release中还有源码可以下载。<a href="https://github.com/shadowsocks/shadowsocks">https://github.com/shadowsocks/shadowsocks</a></p><h1 id="Shadowsocks-rss"><a href="#Shadowsocks-rss" class="headerlink" title="Shadowsocks-rss"></a>Shadowsocks-rss</h1><p>前面认为Shadowssocks特征并不是很明细，但是了解协议工作原理后会发现，SS协议本身还有有漏洞，可以被利用来检测特征，具体讨论看：<a href="https://github.com/breakwa11/shadowsocks-rss/issues/38">ShadowSocks协议的弱点分析和改进</a>。 里面中间那些撕逼就不用看了，我总结了下大致意思是：<br>协议过于简单，并且格式固定，很容易被发起中间人攻击。先看看协议结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------------------+------------------+----------+</span><br><span class="line">| Address Type | Destination Address | Destination Port |   Data   |</span><br><span class="line">+--------------+---------------------+------------------+----------+</span><br><span class="line">|      1       |       Variable      |         2        | Variable |</span><br><span class="line">+--------------+---------------------+------------------+----------+</span><br></pre></td></tr></table></figure><p>Possible values of address type are 1 (IPv4), 4 (IPv6), 3 (hostname). For IPv4 address, it’s packed as a 32-bit (4-byte) big-endian integer. For IPv6 address, a compact representation (16-byte array) is used. For hostname, the first byte of destination address indicates the length, which limits the length of hostname to 255. The destination port is also a big-endian integer.</p><p>The request is encrypted using the specified cipher with a random IV and the pre-shared key, it then becomes so-called payload.</p><p>结构很简单，上面解释也很清楚。Client每一个请求都是这种格式，然后进行加密。Server端解密然后解析。看起来没什么问题，没有密钥你无法模拟中间人攻击，也没什么明显特征。但是看看Server处理逻辑会发现存在一些问题：</p><p>Client数据在加密目前用的最多的是AES系列，加密后在协议数据前会有16位的IV。而Server段解析后，首先判断请求是否有效，而这个判断很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断的依据就是Address Type的那个字节，看它是不是在那三个可能取值，如果不是，立即断开连接，如果是，就尝试解析后面的地址和端口进行连接。</span><br></pre></td></tr></table></figure><p>如果能发起中间人攻击，模拟Client请求，这个就是一个很明显的特征，如果把Address Type穷举各种情况，其中只有3种情况会连接成功。那么很可能就是一个Shadowsocks 服务器。</p><p><strong>所以只需要先劫持一条socks5的请求，因为AES加密后Address Type位置是固定的（第17位），篡改这一位，穷举256种情况（AES-256）</strong>，然后发送给服务器。如果服务器在3种情况没有关闭连接，就说明这个很可能是Shadowsock服务。你这个IP很快就进入关怀列表了。</p><p>这里的关键就是AES加密明文和密文对应关系。密码学不是太懂，贴帖子里面一个回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">举个例子，现在有一个协议包，共7个字节</span><br><span class="line"></span><br><span class="line">0x01, 0x08, 0x08, 0x08, 0x08, 0x00, 0x50</span><br><span class="line">对照socks5协议，很明显这是一个IPv4包(第一个字节是0x01)，目的地是8.8.8.8的80端口</span><br><span class="line"></span><br><span class="line">被shadowsocks加密了以后（密码abc，加密方式aes-256-cfb），数据包就变成了这样</span><br><span class="line"></span><br><span class="line">0xbb, 0x59, 0x1c, 0x4a, 0xb9, 0x0a, 0x91, 0xdc, 0x07, 0xef, 0x72, 0x05, 0x90, 0x42, 0xca, 0x0d, 0x4c, 0x3b, 0x87, 0x8e, 0xca, 0xab, 0x32</span><br><span class="line">前16个字节，从0xbb到0x0d，都是iv，根据issue中提到的弱点和之前的总结，只需要修改0x4c，即真正密文中的第一个字节，就可要起到修改明文中的第一个字节的效果。</span><br><span class="line"></span><br><span class="line">那就把0x4c修改成0x4d吧，解密以后的结果是</span><br><span class="line"></span><br><span class="line">0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x50</span><br><span class="line">的确只有第一个字节被改掉了，根据breakwa11的理论，不难推出其他情况，其中合法的是</span><br><span class="line"></span><br><span class="line">0x4e =&gt; 0x03 (Domain Name)</span><br><span class="line">0x49 =&gt; 0x04 (IPv6)</span><br></pre></td></tr></table></figure><p>所以目前Shadowsocks应该是比较容易被检测出来。但是为什么没有被封掉，呵呵，就不知道了。所以这个项目目的就是在SS基础上进行一些混淆。因为原有实现确实有漏洞。 不过目前这个项目好像也停止更新了。并且木有开源。</p><p>当然如果是自己用完全可以自己修改一个私有协议，这样就没法被检测到了。但是需要同时修改Server段，MAC Client，Windows Client， Android Client。 – -！</p><h1 id="GoAgent和GoProxy"><a href="#GoAgent和GoProxy" class="headerlink" title="GoAgent和GoProxy"></a>GoAgent和GoProxy</h1><p><strong>Google App Engine</strong>是一个开发、托管<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">网络应用程序</a>的平台，使用Google管理的数据中心</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/13.png" alt="13"></p><p>GoAgent的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。它使用<a href="https://zh.wikipedia.org/wiki/Google%E6%87%89%E7%94%A8%E6%9C%8D%E5%8B%99%E5%BC%95%E6%93%8E">Google App Engine</a>的服务器作为中传，将数据包后发送至Google服务器，再由Google服务器转发至目的服务器，接收数据时方法也类似。由于服务器端软件基本相同，该中转服务器既可以是用户自行架设的服务器，也可以是由其他人架设的开放服务器。</p><p>GoAgent其实也是利用GAE作为代理，但是因为他是连接到google的服务器，因为在国内现在google大量被封，所以GoAgent也基本很难使用。目前github上源码也已经删除。</p><p>但是GoAgent本身不依赖于GAE，而且使用Python编写，完全可以部署到VPS上进行代理。GoProxy是GoAgent的后续项目<a href="https://github.com/phuslu/goproxy">https://github.com/phuslu/goproxy</a><br>还有一个XX-NET：<a href="https://github.com/XX-net/XX-Net">https://github.com/XX-net/XX-Net</a> 有兴趣都可以去了解下。</p><h1 id="Tor"><a href="#Tor" class="headerlink" title="Tor"></a>Tor</h1><p><strong>Tor（The Onion Router，洋葱路由器）</strong>是实现匿名通信的自由软件。Tor是第二代洋葱路由的一种实现，用户通过Tor可以在因特网上进行匿名交流。</p><p><a href="https://www.torproject.org/about/overview.html.en">Tor: Overview</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Tor network is a group of volunteer-operated servers that allows people to improve their privacy and security on the Internet. Tor’s users employ this network by connecting through a series of virtual tunnels rather than making a direct connection, thus allowing both organizations and individuals to share information over public networks without compromising their privacy. Along the same line, Tor is an effective censorship circumvention tool, allowing its users to reach otherwise blocked destinations or content. Tor can also be used as a building block for software developers to create new communication tools with built-in privacy features.</span><br></pre></td></tr></table></figure><p>下面的图来自官网的介绍。具体内容大家可以自己看，简单说和其他翻墙方式不同，简单可以理解为Tor有一群代理服务器，然后要访问远端站点，是通过随机的代理路径来完成的，数据经历了多个代理服务器的传递。它主要作用是隐藏访问者信息，而翻墙只是顺带的功能。</p><p>要访问远程站点，Client需要知道Tor nodes，这些nodes就是普通加入的用户，就好像P2P下载一样。获取nodes信息后，会随机选择一条路径访问。 因为这个原因，Tor的速度可能不会很好。</p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/14.png" alt="14"></p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/15.png" alt="15"></p><p><img src="/2023/02/20/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/16.png" alt="16"></p><p>而关于Tor的漏洞和检测看这里：<a href="https://xyinky.fun/2023/02/22/Tor%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/">Tor真的十分安全么 其原理以及漏洞详解!</a></p><p>目前有结合Tor+Shadowsocks前置代理使用的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://plus.google.com/+GhostAssassin/posts/AXgoJutf5sz">VPN翻墙，不安全的加密，不要相信墙内公司</a><br><a href="https://plus.google.com/+GhostAssassin/posts/c1zb7q6xKMA">GFW的工作原理（1） ————GFW是如何识别并封锁翻墙工具的</a><br><a href="https://plus.google.com/+GhostAssassin/posts/TpdEExwyrVj">关于翻墙和匿名与网络安全类科普文大集合</a><br><a href="https://gist.github.com/clowwindy/5947691">为什么不应该用 SSL 翻墙</a><br><a href="https://xyinky.fun/2023/02/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/">科学上网的一些原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>题解ex2</title>
    <link href="http://example.com/2023/02/20/%E9%A2%98%E8%A7%A3ex2/"/>
    <id>http://example.com/2023/02/20/%E9%A2%98%E8%A7%A3ex2/</id>
    <published>2023-02-20T12:02:58.000Z</published>
    <updated>2023-02-20T14:00:26.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2023/02/20/%E9%A2%98%E8%A7%A3ex2/1.png" alt="1"></p><p>​第一眼看到这题还在想，什么情况，洛谷什么时候这么简单的了，仔细看了看，果然</p><p><img src="/2023/02/20/%E9%A2%98%E8%A7%A3ex2/2.png" alt="2"></p><p>​100位数，脑子里第一个想到的就是高精度了吧，但是题目只要求我们比较大小，于是高精度就没什么必要了，我们可以直接用字符串来完成</p><p>原理：string的比较 保存数字的字符串&#x3D;高精度版比较大小</p><p>和字典序什么的有关系</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, id; <span class="comment">// id 记录当上总统的人的号数</span></span><br><span class="line">    string max = <span class="string">&quot;&quot;</span>; <span class="comment">// 赋初值，这个 max 不可以作为全局变量（会重名）</span></span><br><span class="line">    <span class="comment">// 如果一定要把 string max 放到全局变量去，应去掉 using namespce std;</span></span><br><span class="line">    string in;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="type">int</span> inSize = in.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxSize = max.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (inSize &gt; maxSize || (inSize &gt;= maxSize &amp;&amp; in &gt; max)) &#123;</span><br><span class="line">            max = in;</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; id &lt;&lt; endl &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去洛谷逛了一圈发现大佬用结构体做的，定义了三个结构体变量，一个装票数，一个装号数，还有一个装票数的位数。</p><p>重点是排序，<strong>首先我们比较位数，位数多的排前面，如果位数相同就按字典序排列</strong>。</p><p>一系列操作完成后，输入排在首位的答案即可。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string x; <span class="comment">//装票数</span></span><br><span class="line">    <span class="type">int</span> num;  <span class="comment">//装号数</span></span><br><span class="line">    <span class="type">int</span> lenx; <span class="comment">//装票数的位数</span></span><br><span class="line">&#125;s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.lenx&gt;b.lenx) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//前一个比后一个位数多，不交换</span></span><br><span class="line">    <span class="keyword">if</span>(a.lenx==b.lenx&amp;&amp;a.x&gt;b.x) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//位数相同，但前一个按字典序排列比后一个大，也不交换。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//剩下情况均要交换。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i].x;</span><br><span class="line">        s[i].num=i; <span class="comment">//存号数</span></span><br><span class="line">        s[i].lenx=s[i].x.<span class="built_in">size</span>(); <span class="comment">//存票数的位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>,cmp); <span class="comment">//排序</span></span><br><span class="line">    cout&lt;&lt;s[<span class="number">1</span>].num&lt;&lt;endl;  <span class="comment">//输出首位答案即可，注意先输出号数</span></span><br><span class="line">    cout&lt;&lt;s[<span class="number">1</span>].x&lt;&lt;endl; <span class="comment">//再输出票数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="高精度" scheme="http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>链表与邻接表</title>
    <link href="http://example.com/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <id>http://example.com/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</id>
    <published>2023-02-19T14:35:46.000Z</published>
    <updated>2023-03-07T09:44:20.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h3><h4 id="单链表（邻接表）"><a href="#单链表（邻接表）" class="headerlink" title="单链表（邻接表）"></a>单链表（邻接表）</h4><p>​    在算法题中主要存储图和树</p><h5 id="基本样式："><a href="#基本样式：" class="headerlink" title="基本样式："></a>基本样式：</h5><p><img src="/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" alt="1"></p><p>​    每个节点会存一个值和一个next指针，通常在数组模拟时用e[N]表示某个点的值是多少，用ne[N]表示next指针是多少，如上图e[0]表示零号点所存的值为3，ne[0]则表示0号点所指向的1号点，所以ne[0]=1,以此类推e[3]=9,ne[3]=-1,这种类型又叫作静态列表，空节点的下标用-1来表示。算法题通常定义四个变量，head,e[N],ne[N],idx。其中head表示头结点的下标，idx存储当前已经用到了哪个点</p><h5 id="单链表插入及删除操作"><a href="#单链表插入及删除操作" class="headerlink" title="单链表插入及删除操作"></a>单链表插入及删除操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头结点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;      <span class="comment">//表示一个空集</span></span><br><span class="line">    idx = <span class="number">0</span>;        <span class="comment">//表示当前从零号点开始分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">//将x的值存在e里面</span></span><br><span class="line">    ne[idx]=head;   <span class="comment">//将x的next指针指向head所指向的值</span></span><br><span class="line">    head = idx;     <span class="comment">//将head指向x的next指针</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标为k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">//将x的值存在e里面</span></span><br><span class="line">    ne[idx]=ne[k];   <span class="comment">//将x的next指针指向head所指向的值</span></span><br><span class="line">    ne[x] = idx;     <span class="comment">//将head指向x的next指针</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标为k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><p><img src="/2023/02/19/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/ex1.png" alt="ex1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对链表进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//最开始的时候，链表的头节点要指向-1，</span></span><br><span class="line">    <span class="comment">//为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。</span></span><br><span class="line"><span class="comment">    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当它在初始化的时候指向-1，来表示链表离没有内容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找</span></span><br><span class="line">    <span class="comment">//第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下</span></span><br><span class="line">    <span class="comment">//标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的</span></span><br><span class="line"><span class="comment">    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。</span></span><br><span class="line"><span class="comment">    另外，我们遍历链表的时候也是这样，靠的是ne[]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到头节点上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">int_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//和链表中间插入的区别就在于它有head头节点</span></span><br><span class="line">    e[idx] = x;<span class="comment">//第一步，先将值放进去</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了</span></span><br><span class="line">    <span class="comment">//先在只是做到了第一步，将元素x的指针指向了head原本指向的</span></span><br><span class="line">    head = idx;<span class="comment">//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）</span></span><br><span class="line">    idx ++;<span class="comment">//指针向下移一位，为下一次插入元素做准备。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的点的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先将元素插进去</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//让元素x配套的指针，指向它要占位的元素的下一个位置</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让原来元素的指针指向自己</span></span><br><span class="line">    idx ++;<span class="comment">//将idx向后挪</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点个删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">int_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) head = ne[head];<span class="comment">//删除头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);<span class="comment">//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);<span class="comment">//同样的，第k个数，和下标不同，所以要减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表：优化某些问题"><a href="#双链表：优化某些问题" class="headerlink" title="双链表：优化某些问题"></a>双链表：优化某些问题</h4><p>​    通俗来讲，单链表只有一个next指针指向下一个节点，而双链表存在两个next指针，一个指向前，一个指向后，一般定义时定义两个数组l[N],r[N]，l表示指向左边的节点，r则表示指向右边的节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;     <span class="comment">//e表示当前这个点的值是多少，l表示指向左边的节点，r是指向右边的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标是k的点的右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];      <span class="comment">//注意此处r[k]不能用k+1来代替，因为r[k]下一个不一定是k+1，</span></span><br><span class="line">    l[idx] = k;         <span class="comment">//是因为中间如果有删除操作，idx是不会减减的</span></span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈与数列"><a href="#栈与数列" class="headerlink" title="栈与数列"></a>栈与数列</h4><p>栈：先进后出</p><p>队列：先进先出</p><p>数组模拟栈与队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">skt[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt --;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>)<span class="keyword">not</span> empty</span><br><span class="line">    <span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N],hh,tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt)<span class="keyword">not</span> emppty</span><br><span class="line">    <span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL中set的用法</title>
    <link href="http://example.com/2023/02/19/STL%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2023/02/19/STL%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2023-02-19T02:18:17.000Z</published>
    <updated>2023-02-19T14:36:50.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="STL中set的用法"><a href="#STL中set的用法" class="headerlink" title="STL中set的用法"></a>STL中set的用法</h3><p>set，顾名思义，就是数学上的集合——<strong>每个元素最多只出现一次，并且set中的元素已经从小到大排好序</strong>。头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”,前者的元素不能重复，而后者可以包含若干个相等的元素。</p><h3 id="头文件及声明"><a href="#头文件及声明" class="headerlink" title="头文件及声明"></a>头文件及声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;; set&lt;rec&gt; s;   <span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="type">double</span>&gt; s;</span><br></pre></td></tr></table></figure><h3 id="常用的函数："><a href="#常用的函数：" class="headerlink" title="常用的函数："></a>常用的函数：</h3><p>begin()   　　 返回set容器的第一个元素的地址</p><p>end() 　　　　 返回set容器的最后一个元素地址</p><p>clear()  　　   删除set容器中的所有的元素</p><p>empty() 　　　 判断set容器是否为空</p><p>max_size() 　  返回set容器可能包含的元素最大个数</p><p>size() 　　　　 返回当前set容器中的元素个数</p><p>erase(it)       删除迭代器指针it处元素</p><p>样例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 size 值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 maxsize的值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 中的第一个元素是 ：&quot;</span>&lt;&lt;*s.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 中的最后一个元素是:&quot;</span>&lt;&lt;*s.<span class="built_in">end</span>()&lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;set 为空 ！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 size 值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;set 的 maxsize的值为 ：&quot;</span>&lt;&lt;s.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   s.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn). 在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</p><p>​    s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O(logn)。</p><p>还有两个功能类似的函数：count()和find()</p><p>1.count() :用来查找set中某个元素出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</p><p>2.find():  用来查找set中某个元素出现的位置。如果找到，就返回这个元素的迭代器，如果这个元素不存在，则返回 s.end() 。 (最后一个元素的下一个位置，s为set的变量名)</p><h3 id="set的遍历"><a href="#set的遍历" class="headerlink" title="set的遍历"></a>set的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     set&lt;<span class="type">int</span>&gt; s;                <span class="comment">//创建一个int类型的set</span></span><br><span class="line">  </span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">10</span>);                <span class="comment">//插入数据</span></span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="number">40</span>);                 </span><br><span class="line">     <span class="comment">//遍历数据，用迭代器遍历数据</span></span><br><span class="line">     <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)    </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里用到了set中的元素已经从小到大排好序的性质</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后，不得不提的就是结构体类型（struct ）的set ，使用时必须要重载 ‘&lt;’ 运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Info &amp;a) <span class="type">const</span> <span class="comment">// 重载“&lt;”操作符，自定义排序规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按score由大到小排序。如果要由小到大排序，使用“&gt;”即可。</span></span><br><span class="line">        <span class="keyword">return</span> a.score &lt; score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Info&gt; s;</span><br><span class="line">    Info info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入三个元素</span></span><br><span class="line">    info.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    info.score = <span class="number">80</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line">    info.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    info.score = <span class="number">99</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line">    info.name = <span class="string">&quot;Steaven&quot;</span>;</span><br><span class="line">    info.score = <span class="number">60</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(info);</span><br><span class="line"></span><br><span class="line">    set&lt;Info&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; (*it).name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; (*it).score &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Tom : 99</span></span><br><span class="line"><span class="comment">//Jack : 80</span></span><br><span class="line"><span class="comment">//Steaven : 60</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>题解ex1</title>
    <link href="http://example.com/2023/02/14/%E9%A2%98%E8%A7%A3ex1/"/>
    <id>http://example.com/2023/02/14/%E9%A2%98%E8%A7%A3ex1/</id>
    <published>2023-02-13T17:57:44.000Z</published>
    <updated>2023-02-19T14:36:43.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2023/02/14/%E9%A2%98%E8%A7%A3ex1/ex1.png" alt="ex1"></p><p><strong>这道题可以双指针、哈希，但也可以二分，这里就把三种一起讲掉啦！</strong></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h4><p><strong>我们先简化一下问题，变成求Ai+Bj&gt;=x且j要最小。</strong></p><p><strong>我们可以用一个指针i来枚举A中所有数，而用j来枚举B，但由于数组是单调递增的，所以如果Ai+Bj&gt;=x那么Bj+1到Bm就不可能是答案。</strong></p><p><strong>所以j是只能递减的，如此，我们便可以用O(n+m)的时间复杂度通过这道题。</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)cin&gt;&gt;b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]+b[j]&gt;=x)j--;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[i]+b[j+<span class="number">1</span>]==x)</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="二分思路"><a href="#二分思路" class="headerlink" title="二分思路"></a>二分思路</h4><p><strong>既然要找两个和为x的数，那么我们可以把他转换成确定一个y为A，然后快速在B中找出x-y的问题。</strong></p><p><strong>显然我们可以二分查找，算法复杂度为O(nlogn)，可以AC。</strong></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> y = x - a[i];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[mid] == y) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b[mid] &lt; y) </span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="哈希思路"><a href="#哈希思路" class="headerlink" title="哈希思路"></a>哈希思路</h4><p><strong>这个没啥说的，我们可以在输入A时把每个数存在哈希表里，对于每个输入的Bi看看x-Bi是否出现与哈希表即可。</strong></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        h[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">count</span>(x - b[i])) </span><br><span class="line">            cout &lt;&lt; h[x - b[i]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p align="right">written by May(ゝ∀･)</p>                                                                                                                                                        ]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法</title>
    <link href="http://example.com/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-03T04:52:05.000Z</published>
    <updated>2023-02-19T14:36:39.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><p>​        </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//用i“扫描”一遍</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;<span class="built_in">check</span>(i,j))j++;<span class="comment">//确定j的范围以及满足的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,j&lt;n;j++)<span class="comment">//j:j往左最远能到什么地方，j具有单调性</span></span><br><span class="line"><span class="built_in">O</span>(n^<span class="number">2</span>)<span class="comment">//优化时间复杂度，双指针算法为O(n)</span></span><br></pre></td></tr></table></figure><h4 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素算法：O(n^2)//双指针算法：O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">chack</span>(j,i))<span class="keyword">while</span>(j&lt;=i&amp;&amp;<span class="built_in">check</span>(j,i))j++;</span><br><span class="line">            &#123;res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p> <img src="/2023/02/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/ex1.jpg" alt="ex1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];<span class="comment">//s[N]记录某个数出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;<span class="comment">//向s[]中添加新元素</span></span><br><span class="line">        <span class="keyword">while</span>(s[a[i]]&gt;<span class="number">1</span>)<span class="comment">//如果s[]中存在重复元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--;<span class="comment">//将该元素删去</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>通过hexo与github搭建个人平台</title>
    <link href="http://example.com/2023/01/29/%E9%80%9A%E8%BF%87hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%B9%B3%E5%8F%B0/"/>
    <id>http://example.com/2023/01/29/%E9%80%9A%E8%BF%87hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-01-29T09:43:52.000Z</published>
    <updated>2023-02-20T10:07:13.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><ul><li>搭建个人博客组成<ul><li>博客生成框架</li><li>文件托管平台</li><li>站点部署服务</li><li>访问加速服务</li></ul></li></ul><h5 id="博客生成框架"><a href="#博客生成框架" class="headerlink" title="博客生成框架"></a>博客生成框架</h5><p>​它的作用是将用户的输入转化成一个网站目录，由一些html文件，css文件以及js文件组成的目录结构。</p><p>​HTML（Hyper Text Markup Language）又名超文本标记语言，是前端的结构层，从语意的角度去搭建网页结构</p><p>​CSS（Cascading Style Sheet）译为层叠样式表，是前端的样式层，从美观的角度去修饰页面样式</p><p>​js（JavaScript）一种脚本语言，前端的行为层，从交互的角度去描述页面行为</p><p>​简单来说一个博客框架所要达到的效果是作为用户的我们能够以一种相对简单的方式进行博客的设置和书写，然后框架负责帮助我们把这些简单的东西转化成一个完整的复杂的前端界面，本文内容主要以hexo为框架，通过hexo，我们可以用yml进行博客的设置，用markdown来进行博客的书写，hexo会帮我们把这些内容转化成一个完整的网站目录，存放在public文件夹中</p><h5 id="文件托管平台"><a href="#文件托管平台" class="headerlink" title="文件托管平台"></a>文件托管平台</h5><p>​它的作用能够让我们把文件储存在云端并提供相应的访问和修改的接口（当然你是富哥也可以自己买个服务器bushi），本文使用的文件托管平台是github，访问和修改的接口是git</p><h5 id="站点部署服务"><a href="#站点部署服务" class="headerlink" title="站点部署服务"></a>站点部署服务</h5><p>​顾名思义，将一个已经成形的网站部署到互联网上，让网络上的其他主机能够正常访问，我们可以使用github自带的github pages，但是这个站点国内访问速度极慢，本文将使用netlify作为我们部署站点的服务提供商，而把github仅仅作为一个托管文件的场所，这样，我们就能享受到netlify本身的国外加速服务。</p><p>​此外，netlify除了直接部署静态网站的功能之外，还支持动态的构建网站，也就是我们可以自定义一个构建网站的脚本，如npm run clean &amp;&amp; npm run build等脚本，这会先清除之前已经构建好的静态网站，然后重新从头构建，以防某些地方的更新不到位。这样之后我们每次向github commit的时候，netlify都会自动pull并执行上述的脚本，从而保证网站的实时更新</p><h5 id="访问加速服务"><a href="#访问加速服务" class="headerlink" title="访问加速服务"></a>访问加速服务</h5><p>​原理是CDN(Content Deliver Network)加速，即内容交付网络，其原理是通过多结点的缓存来提高网络内容的解析和访问速度，利用的是页面访问的局限性，也就是说刚刚访问过的页面很可能再过不久就会再次访问，这其实和计算机系统中的多级缓存利用程序的局部性是一致的，一个程序刚刚访问过的内存地址附近的地址很可能不久就会再次被访问</p><p>​其基本工作过程是让客户端先访问离自己最近的DNS（Domain Name System）服务器结点，以获取目标内容所在的结点信息，然后根据这个信息去询问CDN服务器结点，由CDN负责从网络中寻找远端的实际存储内容的服务器进行内容的获取，然后将获取的内容缓存下来，这样的话下一次访问就会比较迅速了，从而实现了对网络内容交付的加速</p><p>​这里需要DNS服务器和CDN服务器相互配合，因此他们一般是同一个服务提供商的，比如本文使用的clouldflare。一般来说，我们购买域名之后，提供商默认会为我们分配他自己的DNS服务器，我们需要将这个服务器改成clou了、dflare的DNS服务器，才能享受clouldflare的CDN加速服务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://example.com/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-01-28T16:40:39.000Z</published>
    <updated>2023-02-19T14:36:35.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O（n²）</td><td>O(1)</td><td>in-place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n log²n)</td><td>O(n log²n)</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(n²)</td><td>O(log n)</td><td>in-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>out-place</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>in-place</td><td>不稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>out-place</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>out-place</td><td>稳定</td></tr></tbody></table></div><h3 id="排序算法简介说明"><a href="#排序算法简介说明" class="headerlink" title="排序算法简介说明"></a>排序算法简介说明</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将一组杂乱无章的数据按一定的规律顺次排列起来。例如：</p><p>输入：a1，a2，a3，…，an</p><p>输出：a1’，a2’，a3’，…，an’（满足a1′ &lt;= a2′ &lt;= a3′ &lt;= … &lt;= an’排列）</p><h4 id="2-算法性能评估术语言"><a href="#2-算法性能评估术语言" class="headerlink" title="2. 算法性能评估术语言"></a>2. 算法性能评估术语言</h4><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b时，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b时，排序之后a可能出现在b的后面。</p><p><strong>内排序</strong>：所有排序操作都在内存中完成。<br><strong>外排序</strong>：通常是由于数据太大，不能同时存放在内存中，根据排序过程的需要而在外存与内存之间 数据传输才能进行。</p><p><strong>时间复杂度</strong>：时间频度，一个算法执行所耗费的时间。算法中通常用数据比较次数与数据移动次数 进行衡量。<br><strong>空间复杂度</strong>：算法执行所需要的内存大小。</p></blockquote><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>​        插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 从第一个元素开始，该元素可以认为已经被排序<br>② 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④ 重复步骤③，直到找到已排序的元素小于或者等于新元素的位置<br>⑤将新元素插入到该位置后<br>⑥ 重复步骤②~⑤</p></blockquote><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort.gif" alt="InsertionSort"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><blockquote><p>平均时间复杂度：O(N^2)<br>最差时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>排序方式：In-place<br>稳定性：稳定</p></blockquote><p>如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：</p><blockquote><p>(1) 最好情况：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。<br>(2) 最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。</p></blockquote><p>插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(N^2)。</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0；</p><p>最差的空间复杂度为开始元素为逆排序，则空间复杂度最坏时为 O(N);</p><p>平均的空间复杂度为O(1)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查数据合法性</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//如果比tmp大把值往后移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class="line">               arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法优化改进"><a href="#算法优化改进" class="headerlink" title="算法优化改进"></a>算法优化改进</h4><h5 id="改进方法①"><a href="#改进方法①" class="headerlink" title="改进方法①"></a>改进方法①</h5><p>场景分析：</p><p>直接插入排序每次往前插入时，是按顺序依次往前查找，数据量较大时，必然比较耗时，效率低。</p><p>改进思路： 在往前找合适的插入位置时采用二分查找的方式，即折半插入。</p><p>二分插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，相比直接插入排序，在速度上有一定提升。逻辑步骤：</p><blockquote><p>① 从第一个元素开始，该元素可以认为已经被排序<br>② 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置<br>③将新元素插入到该位置后<br>④ 重复上述两步</p></blockquote><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序改进：二分插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> key, left, right, middle;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        key = a[i];   </span><br><span class="line">        left = <span class="number">0</span>;   </span><br><span class="line">        right = i<span class="number">-1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)   </span><br><span class="line">        &#123;   </span><br><span class="line">            middle = (left+right)/<span class="number">2</span>;   </span><br><span class="line">            <span class="keyword">if</span> (a[middle]&gt;key)   </span><br><span class="line">                right = middle<span class="number">-1</span>;   </span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                left = middle+<span class="number">1</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=left; j--)   </span><br><span class="line">        &#123;   </span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        a[left] = key;          </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进方法②"><a href="#改进方法②" class="headerlink" title="改进方法②"></a>改进方法②</h5><p>场景分析：</p><p>(1) 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。</p><p>(2) 插入排序在每次往前插入时只能将数据移动一位，效率比较低。</p><p>改进思路：</p><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p><p>改进思路二的方法实际上就是希尔排序。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。尤其当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率。 在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。</p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>​        冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。</p><p>​        重复走访要排序的数列，通过两两比较相邻记录的排序码。排序过程中每次从后往前冒一个最小值，且每次能确定一个数在序列中的最终位置。若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。</p><h4 id="实现逻辑-1"><a href="#实现逻辑-1" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p>通过两层循环控制：</p><ul><li>第一个循环（外循环），负责把需要冒泡的那个数字排除在外；</li><li>第二个循环（内循环），负责两两比较交换。</li></ul><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/BubbleSort.gif" alt="BubbleSort"></p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>平均时间复杂度：O(N^2)</li><li>最佳时间复杂度：O(N)</li><li>最差时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>排序方式：In-place</li><li>稳定性：稳定</li></ul><p>解析说明：</p><p>冒泡排序涉及相邻两两数据的比较，故需要嵌套两层 for 循环来控制;</p><p>外层循环 n 次，内层最多时循环 n – 1次、最少循环 0 次，平均循环(n-1)/2;</p><p>所以循环体内总的比较交换次数为：n*(n-1) / 2 = (n^2-n)/2 ;</p><p>按照计算时间复杂度的规则，去掉常数、去掉最高项系数，其复杂度为O(N^2) ;</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0;</p><p>最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);</p><p>平均的空间复杂度为O(1) .</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序(C++)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> i, j;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; len - i; j++)  </span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])  </span><br><span class="line">                <span class="built_in">swap</span>(arr[j - <span class="number">1</span>], arr[j]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h4><h5 id="改进方法①-1"><a href="#改进方法①-1" class="headerlink" title="改进方法①"></a>改进方法①</h5><p>场景一：</p><p>在某次遍历中如果没有数据交换，说明整个数组已经有序。若初始序列就是排序好的，如果用基础的冒泡排序方法，仍然还要比较O(N^2)次，但无交换次数。</p><p>改进思路：</p><p>通过设置标志位来记录此次遍历有无数据交换，进而可以判断是否要继续循环，设置一个flag标记，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变。</p><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序改进(C++)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;        <span class="comment">//比较n-1次</span></span><br><span class="line">        <span class="type">bool</span> exchange = <span class="literal">true</span>;               <span class="comment">//冒泡的改进，若在一趟中没有发生逆序，则该序列已有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len<span class="number">-1</span>; j &gt;i; j--)&#123;     <span class="comment">//每次从后边冒出一个最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])&#123;       <span class="comment">//发生逆序，则交换</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">                exchange = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进方法②-1"><a href="#改进方法②-1" class="headerlink" title="改进方法②"></a>改进方法②</h5><p>场景二：</p><p>如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了。</p><p>改进思路：</p><p>记录某次遍历时最后发生数据交换的位置pos，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p><p>改进代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序改进②</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> j, k;  </span><br><span class="line">    <span class="type">int</span> flag;  </span><br><span class="line">    flag = len;  </span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k = flag;  </span><br><span class="line">        flag = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; k; j++)  </span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">swap</span>(arr[j - <span class="number">1</span>], arr[j]);  </span><br><span class="line">                flag = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，建议采用其它排序方法。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>希尔排序的实质就是分组插入排序，该方法又称递减增量排序算法，因DL．Shell于1959年提出而得名。希尔排序是非稳定的排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><blockquote><p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p></blockquote><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p><p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><h4 id="实现逻辑-2"><a href="#实现逻辑-2" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。<br>② 所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。<br>③ 取第二个增量d2小于d1重复上述的分组和排序，直至所取的增量dt=1(dt小于dt-l小于…小于d2小于d1)，即所有记录放在同一组中进行直接插入排序为止。</p></blockquote><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ShellSort.gif" alt="ShellSort"></p><p>具体我们以一组数字来说操作说明：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ShellSort.jpg" alt="ShellSort"></p><p>假设有一组｛9, 1, 2, 5, 7, 4, 8, 6, 3, 5｝无需序列。</p><blockquote><p><strong>第一趟排序</strong>： 设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。<br><strong>第二趟排序</strong>：<br>将上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为2组。按照直接插入排序的方法对每个组进行排序。<br><strong>第三趟排序</strong>：<br>再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为1的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p></blockquote><p><em>注：需要注意一下的是，图中有两个相等数值的元素5和5。我们可以清楚的看到，在排序过程中，两个元素位置交换了。</em></p><h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h4><blockquote><p>平均时间复杂度：O(Nlog2N)<br>最佳时间复杂度：<br>最差时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：不稳定<br>复杂性：较复杂</p></blockquote><p>希尔排序的效率取决于增量值gap的选取，时间复杂度并不是一个定值。</p><p>开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。</p><p>最优的空间复杂度为开始元素已排序，则空间复杂度为 0；最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);平均的空间复杂度为O(1)希尔排序并不只是相邻元素的比较，有许多跳跃式的比较，难免会出现相同元素之间的相对位置发生变化。比如上面的例子中希尔排序中相等数据5就交换了位置，所以希尔排序是不稳定的算法。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++实现</span></span><br><span class="line"><span class="comment">// 可以使用整数或浮点数作为元素，如果使用类(class)作为元素则需要重载大于(&gt;)运算符。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> gap, i, j;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重点说明-步-摘录自wiki百科"><a href="#重点说明-步-摘录自wiki百科" class="headerlink" title="重点说明(步( 摘录自wiki百科)"></a>重点说明(步( 摘录自wiki百科)</h4><h5 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a><strong>步长序列</strong></h5><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>作者最初的建议是折半再折半知道最后的步长为1&lt;也就是插入排序&gt;,虽然这样取可以比O(n2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如, 如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p><h5 id="常见步长序列"><a href="#常见步长序列" class="headerlink" title="常见步长序列"></a><strong>常见步长序列</strong></h5><blockquote><p>①步长序列：n/2i 最坏情况复杂度：O(n2)<br>②步长序列：2k-1 最坏情况复杂度：O(n3/2)<br>③步长序列：2i3j 最坏情况复杂度：O(nlog2n)</p></blockquote><p><strong>*注意</strong>：由于显示特殊符号存在问题，步长序列中i、k-1，j等都是右上标符号。*</p><p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自9 x 4i – 9 x 2i + 1 和 2i+2 x (2i+2 -3)这两个算式。(注意：公众号里面无法显示特殊符号，两个公式中i，j等都是右上标符号)</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。</p><p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序，又称划分交换排序（partition-exchange sort）</p><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="实现逻辑-3"><a href="#实现逻辑-3" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><blockquote><p>① 从数列中挑出一个元素，称为 “基准”（pivot），<br>② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/QuickSort.gif" alt="QuickSort"></p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><blockquote><p>平均时间复杂度：O(NlogN)<br>最佳时间复杂度：O(NlogN)<br>最差时间复杂度：O(N^2)<br>空间复杂度：根据实现方式的不同而不同</p></blockquote><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,x=q[(l+r)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j),<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，很多面试题中也经常遇到。对于其算法的改进，除了刚刚上文中提到的意外，根据实际场景还有诸多改进方法，包括对小序列采用插入排序替代，三平均划分，三分区划分等改进方法。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><h4 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h4><p>归并排序是用分治思想，分治模式在每一层递归上有三个步骤：</p><ul><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><h4 id="实现逻辑-4"><a href="#实现逻辑-4" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><blockquote><p>① 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>② 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③ 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④ 重复步骤③直到某一指针到达序列尾<br>⑤ 将另一序列剩下的所有元素直接复制到合并序列尾</p></blockquote><h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a><strong>递归法</strong></h5><blockquote><p>① 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素<br>② 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素<br>③ 重复步骤②，直到所有元素排序完毕</p></blockquote><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/MergeSort.gif" alt="MergeSort"></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(nlogn)<br>最佳时间复杂度：O(n)<br>最差时间复杂度：O(nlogn)<br>空间复杂度：O(n)<br>排序方式：In-place<br>稳定性：稳定</p></blockquote><p>不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )</p><p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)。</p><p>归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进-1"><a href="#优化改进-1" class="headerlink" title="优化改进"></a>优化改进</h4><p>在规模较小时，合并排序可采用直接插入，避免递归调用； 在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完。 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>归并排序和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="前缀知识"><a href="#前缀知识" class="headerlink" title="前缀知识"></a>前缀知识</h4><p>堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树</p><h5 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h5><blockquote><p>① 是一棵完全二叉树<br>② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</p></blockquote><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.jpg" alt="Heep1"></p><h5 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h5><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)</p><h5 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h5><p>在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><blockquote><p>① <strong>最大堆调整（Max_Heapify）</strong>：将堆的末端子节点作调整，使得子节点永远小于父节点<br>② <strong>创建最大堆（Build_Max_Heap）</strong>：将堆所有数据重新排序<br>③ <strong>堆排序（HeapSort）</strong>：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p></blockquote><h4 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h4><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p><blockquote><p>① 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点<br>② 依次将根节点与待排序序列的最后一个元素交换<br>③ 再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列</p></blockquote><h4 id="实现逻辑-5"><a href="#实现逻辑-5" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。<br>② 再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key<br>③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>④ 直到无序区只有一个元素为止。</p></blockquote><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heepsort1.gif" alt="Heepsort1"></p><p>​    堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><p><strong>分步解析说明</strong>：</p><p>实现堆排序需要解决两个问题：</p><blockquote><p>1、如何由一个无序序列建成一个堆？<br>2、如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p></blockquote><p>假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep2.jpg" alt="Heep2"></p><h5 id="创建最大堆"><a href="#创建最大堆" class="headerlink" title="创建最大堆"></a>创建最大堆</h5><p>①首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆。每一个三角关系都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子；</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.1.jpg" alt="Heep1.1"></p><p>②转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.1.jpg" alt="Heep1.1"></p><p>③从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。</p><p>④第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.2.jpg" alt="Heep1.2"></p><p>⑤对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。</p><p>⑥最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.3.jpg" alt="Heep1.3"></p><h5 id="堆排序（最大堆调整）"><a href="#堆排序（最大堆调整）" class="headerlink" title="堆排序（最大堆调整）"></a>堆排序（最大堆调整）</h5><p>①首先将堆顶元素100交换至最底部7的位置，7升至堆顶，100所在的底部位置即为有序区，有序区不参与之后的任何对比。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.4.jpg" alt="Heep1.4"></p><p>②在7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.5.jpg" alt="Heep1.5"></p><p>③在7被交换下来后，下面还有子节点，所以需要继续与子节点对比，左孩子11比7大，所以11与7交换位置，交换位置后7下面为有序区，不参与对比，所以本轮结束，无序区再次形成一个最大堆。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.6.jpg" alt="Heep1.6"></p><p>④将最大堆堆顶33交换至堆末尾，扩大有序区；</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.7.jpg" alt="Heep1.7"></p><p>⑤不断建立最大堆，并且扩大有序区，最终全部有序。</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Heep1.8.jpg" alt="Heep1.8"></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>平均时间复杂度：O(nlogn)</li><li>最佳时间复杂度：O(nlogn)</li><li>最差时间复杂度：O(nlogn)</li><li>稳定性：不稳定</li></ul><p>堆排序其实也是一种选择排序，是一种树形选择排序。只不过直接选择排序中，为了从R[1…n]中选择最大记录，需比较n-1次，然后从R[1…n-2]中选择最大记录需比较n-2次。事实上这n-2次比较中有很多已经在前面的n-1次比较中已经做过，而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。对于n个关键字序列，最坏情况下每个节点需比较log2(n)次，因此其最坏情况下时间复杂度为nlogn。堆排序为不稳定排序，不适合记录较少的排序。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>堆是一种很好做调整的结构，在算法题里面使用频度很高。常用于想知道最大值或最小值的情况，比如优先级队列，作业调度等场景。</p><p>堆排序相看似比较复杂（建堆的过程，堆调整的过程，堆排序等等），需要好好推敲揣摩理清思路。堆排序操作过程中其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</p><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p><strong>计数排序（Counting sort）</strong>是一种稳定的线性时间排序算法。</p><h4 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h4><p>计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），然后进行分配、收集处理：</p><blockquote><p>① <strong>分配</strong>。扫描一遍原始数组，以当前值-minValue作为下标，将该下标的计数器增1。<br>② <strong>收集</strong>。扫描一遍计数器数组，按顺序把值收集起来。</p></blockquote><h4 id="实现逻辑-6"><a href="#实现逻辑-6" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 找出待排序的数组中最大和最小的元素<br>② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>④ 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></blockquote><h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CountingSort.gif" alt="CountingSort"></p><p>举个例子，假设有无序数列nums=[2, 1, 3, 1, 5], 首先扫描一遍获取最小值和最大值，maxValue=5, minValue=1，于是开一个长度为5的计数器数组counter</p><blockquote><p><strong>(1) 分配</strong><br>统计每个元素出现的频率，得到counter=[2, 1, 1, 0, 1]，例如counter[0]表示值0+minValue=1出现了2次。<br><strong>(2) 收集</strong><br>counter[0]=2表示1出现了两次，那就向原始数组写入两个1，counter[1]=1表示2出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为[1,1,2,3,5]，排序好了。</p></blockquote><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n + k)<br>空间复杂度：O(n + k)</p></blockquote><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。</p><p>计数排序需要两个额外的数组用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)。</p><p>计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。</p><p>计数排序的稳定性很重要的一个原因是：计数排序经常会被用于基数排序算法的一个子过程。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> maxVal)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxVal+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(arr)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line">count[x]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxVal; ++i)</span><br><span class="line">count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">arr[count[tmp[i]] - <span class="number">1</span>] = tmp[i];</span><br><span class="line">count[tmp[i]]--;<span class="comment">//注意这里要减1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> maxVal = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">CountSort</span>(arr,maxVal);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化改进-2"><a href="#优化改进-2" class="headerlink" title="优化改进"></a>优化改进</h4><p><strong>场景分析：</strong>举个极端的例子：如果排序的数组有200W个元素，但是这200W个数的值都在1000000-1000100，也就说有100个数，总共重复了200W次，现在要排序，怎么办？</p><p>这种情况排序，计数排序应该是首选。但是这时候n的值为200W，如果按原来的算法，k的值10001000，但是此时c中真正用到的地方只有100个，这样对空间造成了极大的浪费。</p><p><strong>改进思路：</strong>针对c数组的大小，优化计数排序</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>计数算法只能使用在已知序列中的元素在0-k之间，且要求排序的复杂度在线性效率上。 Â 计数排序和基数排序很类似，都是非比较型排序算法。但是，它们的核心思想是不同的，基数排序主要是按照进制位对整数进行依次排序，而计数排序主要侧重于对有限范围内对象的统计。基数排序可以采用计数排序来实现。</p><h3 id="桶排序（BucketSort）"><a href="#桶排序（BucketSort）" class="headerlink" title="桶排序（BucketSort）"></a>桶排序（BucketSort）</h3><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p><h4 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h4><p>桶排序的思想近乎彻底的<strong>分治思想</strong>。</p><p>桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。</p><p>然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。</p><p>接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。</p><blockquote><p>补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数</p></blockquote><p>为了使桶排序更加高效，我们需要做到这两点：</p><blockquote><p>1、在额外空间充足的情况下，尽量增大桶的数量；<br>2、使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中；</p></blockquote><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h4 id="实现逻辑-7"><a href="#实现逻辑-7" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><ul><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ul><h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/BucketSort.gif" alt="BucketSort"></p><p>分步骤图示说明：设有数组 array = [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]，对其进行桶排序：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket.jpg" alt="Bucket"></p><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n ^ 2)<br>空间复杂度：O(n * k)<br>稳定性：稳定</p></blockquote><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p>假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">ListNode* mNext;</span><br><span class="line"><span class="type">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">ListNode *pre,*curr;</span><br><span class="line">dummyNode.mNext = head;</span><br><span class="line">pre = &amp;dummyNode;</span><br><span class="line">curr = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;mNext = curr;</span><br><span class="line">pre-&gt;mNext = newNode;</span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *dummy = &amp;dummyNode;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line"><span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">dummy-&gt;mNext = head1;</span><br><span class="line">head1 = head1-&gt;mNext;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dummy-&gt;mNext = head2;</span><br><span class="line">head2 = head2-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="type">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">arr[i] = head-&gt;mData;</span><br><span class="line">head = head-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>桶排序是计数排序的变种，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p><p>算法思想和散列中的开散列法差不多，当冲突时放入同一个桶中；可应用于数据量分布比较均匀，或比较侧重于区间数量时。</p><p>桶排序最关键的建桶，如果桶设计得不好的话桶排序是几乎没有作用的。通常情况下，上下界有两种取法，第一种是取一个10^n或者是2^n的数，方便实现。另一种是取数列的最大值和最小值然后均分作桶.</p><h3 id="基数排序（RadixSort）"><a href="#基数排序（RadixSort）" class="headerlink" title="基数排序（RadixSort）"></a>基数排序（RadixSort）</h3><p>基数排序（Radix sort）是一种非比较型整数排序算法。</p><h4 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h4><p>原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><ul><li><strong>MSD</strong>：先从高位开始进行排序，在每个关键字上，可采用计数排序</li><li><strong>LSD</strong>：先从低位开始进行排序，在每个关键字上，可采用桶排序</li></ul><h4 id="实现逻辑-8"><a href="#实现逻辑-8" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><blockquote><p>① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>② 从最低位开始，依次进行一次排序。<br>③ 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><h4 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h4><p>google上没搜到吗，因此没有动图演示。</p><p>分步图示说明：设有数组 array = {53, 3, 542, 748, 14, 214, 154, 63, 616}，对其进行基数排序：</p><p><img src="/2023/01/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/RadixSort.jpg" alt="RadixSort"></p><p>在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。</p><ul><li>按照个位数进行排序。</li><li>按照十位数进行排序。</li><li>按照百位数进行排序。</li></ul><p>排序后，数列就变成了一个有序序列。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>时间复杂度：O(k*N)<br>空间复杂度：O(k + N)<br>稳定性：稳定</p></blockquote><p>设待排序的数组R[1..n]，数组中最大的数是d位数，基数为r（如基数为10，即10进制，最大有10种可能，即最多需要10个桶来映射数组元素）。</p><p>处理一位数，需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历数组一遍，最多元素数为n，则时间复杂度为O(n+r)。所以，总的时间复杂度为O(d*(n+r))。</p><p>基数排序过程中，用到一个计数器数组，长度为r，还用到一个r<em>n的二位数组来做为桶，所以空间复杂度为O(r</em>n)。</p><p>基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];      <span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*    int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><p>基数排序不是直接根据元素整体的大小进行元素比较，而是将原始列表元素分成多个部分，对每一部分按一定的规则进行排序，进而形成最终的有序列表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>cpp语法</title>
    <link href="http://example.com/2023/01/28/cpp%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/01/28/cpp%E8%AF%AD%E6%B3%95/</id>
    <published>2023-01-28T14:49:34.000Z</published>
    <updated>2023-02-19T14:36:47.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1><h4 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h4><h6 id="D-i，-j-xi-xj-yi-yj"><a href="#D-i，-j-xi-xj-yi-yj" class="headerlink" title="D (i， j)=|xi-xj|+|yi-yj|"></a>D (i， j)=|xi-xj|+|yi-yj|</h6><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><h6 id="证明：设a-k-b-r-k和r分别是a除以b得到的商和余数"><a href="#证明：设a-k-b-r-k和r分别是a除以b得到的商和余数" class="headerlink" title="证明：设a=k*b+r,k和r分别是a除以b得到的商和余数"></a>证明：设a=k*b+r,k和r分别是a除以b得到的商和余数</h6><p>则有a-r=k<em>b成立<br>设d是a和b的公约数<br>那么由a=k</em>b+r，得d也是r的一个因数<br>因此d是b和r的公因数<br>因此d既是a和b的公因数，也是b和a%b的公因数<br>那么，最大公因数也相等<br>即gcd=(a,b)=gcd(b,a%b)<br>证毕。</p><p>int gcd(int a,int b)</p><p>{<br>    if(b==0)<br>        return a;<br>    else<br>        return gcd(b,a%b);<br>}</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;          <span class="comment">//动态变化的int数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;rec&gt; c;          <span class="comment">//自定义结构体类型也可保存于vector</span></span><br><span class="line"></span><br><span class="line">size<span class="comment">//函数返回vector的实际长度</span></span><br><span class="line"></span><br><span class="line">empty<span class="comment">//函数返回一个bool类型</span></span><br><span class="line"></span><br><span class="line">clear<span class="comment">//函数把vector清空</span></span><br></pre></td></tr></table></figure><h4 id="迭代器（类似STL的指针）"><a href="#迭代器（类似STL的指针）" class="headerlink" title="迭代器（类似STL的指针）"></a>迭代器（类似STL的指针）</h4><p>声明：vector<int>::iterator it;</int></p><p>begin函数返回vector第一个元素的迭代器，*a.begin()与a[0]相同,end同理</p><p>front函数返回vector第一个元素</p><p>back函数返回vector最后一个元素</p><p>a.push_back(x)把元素x插入vector a的尾部</p><p>b.pop_back()删除vector a的最后一个元素</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>include <queue>包括循环队列queue和优先队列priority_queue两个容器</queue></p><p>声明: queue<int> q;</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;...&#125;;queue&lt;rec&gt;q     <span class="comment">//rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">priority queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;q;  <span class="comment">//小于堆</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列 queue</span></span><br><span class="line"></span><br><span class="line">   push 从队尾插入</span><br><span class="line"></span><br><span class="line">   pop 从队头弹出</span><br><span class="line"></span><br><span class="line">   front 返回队头元素</span><br><span class="line"></span><br><span class="line">   back 返回队尾元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先队列 priority_queue</span></span><br><span class="line"></span><br><span class="line">   push 把元素插入堆</span><br><span class="line"></span><br><span class="line">   pop 删除堆顶元素</span><br><span class="line"></span><br><span class="line">   top 查询堆顶元素（最大值）</span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p> include <stack></stack></p><p>头文件stack包含栈。声明和前面的容器类似。</p><p>push 向栈顶插入</p><p>pop 弹出栈顶元素</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间,类似vector和queue的结合</p><p>begin/end，返回deque的头/尾迭代器</p><p>front/back 队头/队尾元素</p><p>push_back 从队尾入队</p><p>push_front 从队头入队</p><p>pop_back 从队尾出队</p><p>pop_front 从队头出队</p><p>clear 清空队列</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line">  map&lt;key_type, value_type&gt; name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//例如：</span></span><br><span class="line"></span><br><span class="line">  map&lt;<span class="type">long</span>, <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">  map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>&amp; 与</p><p>| 或</p><p>~ 非</p><p>^ 异或</p><p>>&gt; 右移</p><p>&lt;&lt; 左移</p><p>常用操作：</p><p>(1)  求x的第k位数字 x &gt;&gt; k &amp; 1                          //1.先把第k位移到最后一位x&gt;&gt;k；2.再看看个位是几 x&1;</p><p>(2)  lowbit(x) ，返回x的最后一位1      //若x=101000，则lowbit(x)=1000; x=1010，则lowbit(x)=10;</p><p>​      x&amp;-x==x&amp;(~x+1)</p><p>​      若x=101000，则~x=010111，~x+1=010100，x&amp;(~x+1)=0001000</p><h4 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h4><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>​    翻转一个vector</p><p>​    reverse(a.begin(),a,end());</p><p>​    翻转一个数组</p><p>​    reverse（a+1，a+1+n）;</p><h5 id="unique-前闭后开"><a href="#unique-前闭后开" class="headerlink" title="unique(前闭后开)"></a>unique(前闭后开)</h5><p>​    去重vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m =<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())-a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>​    去重数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m =<span class="built_in">unique</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-(a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="random-shuffle（随机打乱）"><a href="#random-shuffle（随机打乱）" class="headerlink" title="random,shuffle（随机打乱）"></a>random,shuffle（随机打乱）</h5><p>​    用法和reverse相同</p><h5 id="sort-快排"><a href="#sort-快排" class="headerlink" title="sort(快排)"></a>sort(快排)</h5><p>​    sort(a.begin(),a.end())</p><h5 id="lower-bound-upper-bound-二分"><a href="#lower-bound-upper-bound-二分" class="headerlink" title="lower_bound/upper_bound(二分)"></a>lower_bound/upper_bound(二分)</h5><p>​    解析:lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。</p><p>upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p><p>​    在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> I = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n,. x) – a;</span><br></pre></td></tr></table></figure><p>在有序vector<int> 中查找小于等于x的最大整数（假设一定存在）</int></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = *--<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="语法" scheme="http://example.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
